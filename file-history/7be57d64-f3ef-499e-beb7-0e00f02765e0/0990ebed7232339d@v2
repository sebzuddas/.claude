// Particle System Simulator with P5.js

let particles = [];
let particleCount = 100;
let gravity = 0.5;
let damping = 0.99;
let isPaused = false;
let mouseAttraction = false;
let trailMode = false;

// Physics constants
const BOUNCE_DAMPING = 0.8;
const MOUSE_FORCE = 50;
const PARTICLE_SIZE = 4;

// Spatial grid for collision optimization
const GRID_CELL_SIZE = 50;
let spatialGrid = {};

// Schema for validation
const particleSchema = {
    type: 'object',
    required: ['modelType']
};

class Particle {
    constructor(x, y, vx = 0, vy = 0) {
        this.pos = createVector(x || random(width), y || random(height));
        this.vel = createVector(vx || random(-2, 2), vy || random(-2, 2));
        this.acc = createVector(0, 0);
        this.size = random(2, 6);
        this.mass = this.size * 0.1;
        this.color = color(random(100, 255), random(100, 255), random(100, 255), 180);
        this.trail = [];
        this.maxTrailLength = 20;
        this.trailIndex = 0; // Circular buffer index
    }
    
    applyForce(force) {
        const f = p5.Vector.div(force, this.mass);
        this.acc.add(f);
    }
    
    update() {
        if (isPaused) return;
        
        // Apply gravity
        const gravityForce = createVector(0, gravity * this.mass);
        this.applyForce(gravityForce);
        
        // Apply mouse attraction/repulsion
        if (mouseAttraction && (mouseIsPressed || touches.length > 0)) {
            const mousePos = createVector(mouseX, mouseY);
            const force = p5.Vector.sub(mousePos, this.pos);
            const distance = force.mag();
            
            if (distance > 0 && distance < 200) {
                force.normalize();
                force.mult(MOUSE_FORCE / (distance * 0.1));
                
                // Repel if right mouse button or two fingers
                if (mouseButton === RIGHT || touches.length > 1) {
                    force.mult(-1);
                }
                
                this.applyForce(force);
            }
        }
        
        // Update kinematics
        this.vel.add(this.acc);
        this.vel.mult(damping);
        this.pos.add(this.vel);
        this.acc.mult(0);
        
        // Boundary collisions
        this.handleBoundaries();

        // Update trail using circular buffer (more efficient than shift())
        if (trailMode) {
            this.trail[this.trailIndex % this.maxTrailLength] = this.pos.copy();
            this.trailIndex++;
        }
    }
    
    handleBoundaries() {
        // Floor collision
        if (this.pos.y > height - this.size/2) {
            this.pos.y = height - this.size/2;
            this.vel.y *= -BOUNCE_DAMPING;
        }
        
        // Ceiling collision
        if (this.pos.y < this.size/2) {
            this.pos.y = this.size/2;
            this.vel.y *= -BOUNCE_DAMPING;
        }
        
        // Wall collisions
        if (this.pos.x > width - this.size/2) {
            this.pos.x = width - this.size/2;
            this.vel.x *= -BOUNCE_DAMPING;
        }
        
        if (this.pos.x < this.size/2) {
            this.pos.x = this.size/2;
            this.vel.x *= -BOUNCE_DAMPING;
        }
    }
    
    display() {
        // Draw trail
        if (trailMode && this.trail.length > 1) {
            stroke(red(this.color), green(this.color), blue(this.color), 100);
            strokeWeight(1);
            noFill();
            
            beginShape();
            for (let pos of this.trail) {
                vertex(pos.x, pos.y);
            }
            endShape();
        }
        
        // Draw particle
        fill(this.color);
        noStroke();
        ellipse(this.pos.x, this.pos.y, this.size, this.size);
        
        // Add glow effect
        fill(red(this.color), green(this.color), blue(this.color), 50);
        ellipse(this.pos.x, this.pos.y, this.size * 2, this.size * 2);
    }
    
    // Check collision with other particle
    collidesWith(other) {
        const distance = p5.Vector.dist(this.pos, other.pos);
        return distance < (this.size + other.size) / 2;
    }
    
    // Resolve collision with another particle
    resolveCollision(other) {
        const distance = p5.Vector.dist(this.pos, other.pos);
        const minDistance = (this.size + other.size) / 2;
        
        if (distance < minDistance) {
            // Calculate collision normal
            const normal = p5.Vector.sub(other.pos, this.pos);
            normal.normalize();
            
            // Separate particles
            const overlap = minDistance - distance;
            const separation = p5.Vector.mult(normal, overlap / 2);
            
            this.pos.sub(separation);
            other.pos.add(separation);
            
            // Calculate relative velocity
            const relativeVel = p5.Vector.sub(other.vel, this.vel);
            const velAlongNormal = p5.Vector.dot(relativeVel, normal);
            
            if (velAlongNormal > 0) return; // Objects separating
            
            // Calculate collision impulse
            const restitution = 0.8;
            const impulse = -(1 + restitution) * velAlongNormal / (1/this.mass + 1/other.mass);
            
            const impulseVector = p5.Vector.mult(normal, impulse);
            
            this.vel.sub(p5.Vector.div(impulseVector, this.mass));
            other.vel.add(p5.Vector.div(impulseVector, other.mass));
        }
    }
}

// Spatial grid helper functions for O(n) collision detection
function getGridKey(x, y) {
    const gridX = Math.floor(x / GRID_CELL_SIZE);
    const gridY = Math.floor(y / GRID_CELL_SIZE);
    return `${gridX},${gridY}`;
}

function buildSpatialGrid() {
    spatialGrid = {};
    for (let particle of particles) {
        const key = getGridKey(particle.pos.x, particle.pos.y);
        if (!spatialGrid[key]) {
            spatialGrid[key] = [];
        }
        spatialGrid[key].push(particle);
    }
}

function getNearbyParticles(particle) {
    const nearby = [];
    const gridX = Math.floor(particle.pos.x / GRID_CELL_SIZE);
    const gridY = Math.floor(particle.pos.y / GRID_CELL_SIZE);

    // Check current cell and 8 neighboring cells
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            const key = `${gridX + dx},${gridY + dy}`;
            if (spatialGrid[key]) {
                nearby.push(...spatialGrid[key]);
            }
        }
    }
    return nearby;
}

function setup() {
    // Create canvas in the container
    const container = document.getElementById('viz-canvas-container');
    const canvas = createCanvas(800, 600);
    canvas.parent(container);
    canvas.id('viz-canvas');
    
    // Initialize with data from URL or demo setup
    initializeSimulation();
    
    // Setup event listeners
    setupEventListeners();
    
    // Create initial particles
    resetParticles();
}

function draw() {
    // Background with fade effect for trails
    if (trailMode) {
        fill(0, 0, 0, 20);
        noStroke();
        rect(0, 0, width, height);
    } else {
        background(20);
    }

    // Update particles
    for (let particle of particles) {
        particle.update();
    }

    // Build spatial grid for efficient collision detection
    buildSpatialGrid();

    // Check collisions using spatial grid (O(n) instead of O(nÂ²))
    const checkedPairs = new Set();
    for (let particle of particles) {
        const nearby = getNearbyParticles(particle);
        for (let other of nearby) {
            if (particle === other) continue;

            // Create unique pair identifier to avoid duplicate checks
            const pairId = particle.size < other.size
                ? `${particles.indexOf(particle)}-${particles.indexOf(other)}`
                : `${particles.indexOf(other)}-${particles.indexOf(particle)}`;

            if (checkedPairs.has(pairId)) continue;
            checkedPairs.add(pairId);

            if (particle.collidesWith(other)) {
                particle.resolveCollision(other);
            }
        }
    }

    // Display particles
    for (let particle of particles) {
        particle.display();
    }

    // Draw mouse influence area
    if (mouseAttraction && (mouseIsPressed || touches.length > 0)) {
        stroke(255, 100);
        strokeWeight(1);
        noFill();
        ellipse(mouseX, mouseY, 200, 200);
    }

    // Draw UI info
    drawUI();
}

function drawUI() {
    // Performance info
    fill(255, 200);
    noStroke();
    textAlign(LEFT, TOP);
    textSize(10);
    
    const fps = Math.round(frameRate());
    text(`FPS: ${fps}`, 10, 10);
    text(`Particles: ${particles.length}`, 10, 25);
    text(`Gravity: ${gravity.toFixed(1)}`, 10, 40);
    text(`Damping: ${damping.toFixed(2)}`, 10, 55);
    
    if (isPaused) {
        textAlign(CENTER, CENTER);
        textSize(24);
        fill(255, 0, 0, 150);
        text('PAUSED', width/2, height/2);
    }
    
    // Instructions
    textAlign(LEFT, BOTTOM);
    textSize(9);
    fill(255, 150);
    text('Click and drag: Attract particles', 10, height - 45);
    text('Right click: Repel particles', 10, height - 30);
    text('T: Toggle trail mode', 10, height - 15);
}

function initializeSimulation() {
    // Try to get data from various sources
    const urlData = DataParser.parseURLParams();
    const hashData = DataParser.parseHashData();
    
    if (urlData.error || hashData.error) {
        Utils.showMessage(urlData.error || hashData.error, 'error');
        return;
    }
    
    if (urlData.demo || (!urlData.data && !hashData.data)) {
        // Use default demo settings
        Utils.showMessage('Demo simulation loaded. Upload JSON config or use controls.', 'success');
    } else {
        // Use provided configuration
        const config = urlData.data || hashData.data;
        setSimulationConfig(config);
    }
}

function setSimulationConfig(config) {
    // Validate configuration
    const validation = DataParser.validateData(config, particleSchema);
    if (!validation.valid) {
        Utils.showMessage('Invalid config: ' + validation.errors.join(', '), 'error');
        return;
    }
    
    if (config.parameters) {
        const params = config.parameters;
        
        if (params.particleCount !== undefined) {
            particleCount = Utils.clamp(params.particleCount, 10, 500);
            document.getElementById('particleCount').value = particleCount;
            document.getElementById('particleCountValue').textContent = particleCount;
        }
        
        if (params.gravity !== undefined) {
            gravity = Utils.clamp(params.gravity, 0, 2);
            document.getElementById('gravity').value = gravity * 10;
            document.getElementById('gravityValue').textContent = gravity.toFixed(1);
        }
        
        if (params.damping !== undefined) {
            damping = Utils.clamp(params.damping, 0.9, 1.0);
            document.getElementById('damping').value = damping * 100;
            document.getElementById('dampingValue').textContent = damping.toFixed(2);
        }
    }
    
    resetParticles();
    Utils.showMessage('Simulation configuration loaded!', 'success');
}

function resetParticles() {
    particles = [];
    
    for (let i = 0; i < particleCount; i++) {
        // Create particles with initial conditions
        let x, y, vx, vy;
        
        // Spawn from top with some variation
        x = random(50, width - 50);
        y = random(-100, 50);
        vx = random(-1, 1);
        vy = random(0, 2);
        
        particles.push(new Particle(x, y, vx, vy));
    }
}

function setupEventListeners() {
    // Particle count slider
    const particleCountSlider = document.getElementById('particleCount');
    const particleCountValue = document.getElementById('particleCountValue');
    
    particleCountSlider.addEventListener('input', (e) => {
        particleCount = parseInt(e.target.value);
        particleCountValue.textContent = particleCount;
        resetParticles();
    });
    
    // Gravity slider
    const gravitySlider = document.getElementById('gravity');
    const gravityValue = document.getElementById('gravityValue');
    
    gravitySlider.addEventListener('input', (e) => {
        gravity = parseFloat(e.target.value) / 10;
        gravityValue.textContent = gravity.toFixed(1);
    });
    
    // Damping slider
    const dampingSlider = document.getElementById('damping');
    const dampingValue = document.getElementById('dampingValue');
    
    dampingSlider.addEventListener('input', (e) => {
        damping = parseFloat(e.target.value) / 100;
        dampingValue.textContent = damping.toFixed(2);
    });
    
    // Reset button
    document.getElementById('resetBtn').addEventListener('click', resetParticles);
    
    // Pause button
    document.getElementById('pauseBtn').addEventListener('click', () => {
        isPaused = !isPaused;
        document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
    });
    
    // Export functionality
    document.getElementById('exportBtn').addEventListener('click', () => {
        save('particle-system.png');
        Utils.showMessage('Image exported successfully!', 'success');
    });
    
    // File drop zone
    FileHandler.setupDropZone('drop-zone', (result) => {
        if (result.error) {
            Utils.showMessage(result.error, 'error');
        } else if (result.data) {
            setSimulationConfig(result.data);
        }
    });
    
    // PostMessage listener for iframe integration
    MessageHandler.setupPostMessageListener((config) => {
        setSimulationConfig(config);
        Utils.showMessage('Configuration updated via PostMessage', 'success');
    });
}

function keyPressed() {
    switch (key.toLowerCase()) {
        case 't':
            trailMode = !trailMode;
            if (!trailMode) {
                // Clear trails and reset circular buffer
                particles.forEach(p => {
                    p.trail = [];
                    p.trailIndex = 0;
                });
            }
            break;
        case ' ':
            isPaused = !isPaused;
            break;
        case 'r':
            resetParticles();
            break;
        case 'm':
            mouseAttraction = !mouseAttraction;
            break;
    }
}

function mousePressed() {
    mouseAttraction = true;
}

function mouseReleased() {
    mouseAttraction = false;
}

function touchStarted() {
    mouseAttraction = true;
}

function touchEnded() {
    mouseAttraction = false;
}

function windowResized() {
    // Responsive canvas
    const container = document.getElementById('viz-canvas-container');
    const containerWidth = container.clientWidth;
    const newWidth = Math.min(containerWidth, 1000);
    const newHeight = Math.max(400, newWidth * 0.75);
    
    resizeCanvas(newWidth, newHeight);
    
    // Adjust particle positions if canvas is smaller
    for (let particle of particles) {
        particle.pos.x = Utils.clamp(particle.pos.x, 0, width);
        particle.pos.y = Utils.clamp(particle.pos.y, 0, height);
    }
}