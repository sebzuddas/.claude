'use client'

import { useEffect, useRef, useState } from 'react'
import { TypographyUtils } from '@/lib/utils'
import type { ScatterPlotData, VisualizationProps } from '@/types'

interface ScatterPlotProps extends VisualizationProps {
  data: ScatterPlotData
}

export default function ScatterPlot({
  data,
  width = 900,
  height = 600,
  onError
}: ScatterPlotProps) {
  const canvasRef = useRef<HTMLDivElement>(null)
  const [p5Instance, setP5Instance] = useState<any>(null)

  // Control states
  const [pointSize, setPointSize] = useState(6)
  const [showTrendLine, setShowTrendLine] = useState(true)

  // Use ref to avoid recreating P5 instance
  const controlsRef = useRef({ pointSize, showTrendLine })

  useEffect(() => {
    controlsRef.current = { pointSize, showTrendLine }
  }, [pointSize, showTrendLine])

  useEffect(() => {
    let p5: any
    let isMounted = true

    const loadP5 = async () => {
      if (typeof window !== 'undefined' && canvasRef.current) {
        // Clear any existing canvases
        if (canvasRef.current) {
          canvasRef.current.innerHTML = ''
        }

        const p5Module = await import('p5')
        const P5 = p5Module.default

        if (!isMounted) return

        // Load font sizes (use local variables, not state)
        let titleSize = 20
        let labelSize = 12
        let tickSize = 10

        try {
          const [loadedTitleSize, loadedLabelSize, loadedTickSize] = await Promise.all([
            TypographyUtils.getVisualizationFontSize('scatter', 'titleSize'),
            TypographyUtils.getVisualizationFontSize('scatter', 'labelSize'),
            TypographyUtils.getVisualizationFontSize('scatter', 'fontSize')
          ])

          if (!isMounted) return

          titleSize = loadedTitleSize
          labelSize = loadedLabelSize
          tickSize = loadedTickSize
        } catch (error) {
          console.warn('Could not load font sizes, using defaults')
        }

        if (!isMounted) return

        const sketch = (p: any) => {
          const marginLeft = 80
          const marginRight = 50
          const marginTop = 60
          const marginBottom = 80

          let xMin: number, xMax: number, yMin: number, yMax: number
          let hoveredPoint: any = null

          const calculateRanges = () => {
            if (!data?.points || data.points.length === 0) return

            const xValues = data.points.map(pt => pt.x)
            const yValues = data.points.map(pt => pt.y)

            xMin = Math.min(...xValues)
            xMax = Math.max(...xValues)
            yMin = Math.min(...yValues)
            yMax = Math.max(...yValues)

            // Add padding
            const xPadding = (xMax - xMin) * 0.1
            const yPadding = (yMax - yMin) * 0.1

            xMin -= xPadding
            xMax += xPadding
            yMin -= yPadding
            yMax += yPadding
          }

          const drawAxes = () => {
            p.stroke(100)
            p.strokeWeight(1)

            // X-axis
            p.line(marginLeft, height - marginBottom, width - marginRight, height - marginBottom)

            // Y-axis
            p.line(marginLeft, marginTop, marginLeft, height - marginBottom)

            // Tick marks and labels
            p.fill(60)
            p.noStroke()
            p.textAlign(p.CENTER, p.TOP)
            p.textSize(tickSize)

            // X-axis ticks
            const numXTicks = 8
            for (let i = 0; i <= numXTicks; i++) {
              const x = p.map(i, 0, numXTicks, marginLeft, width - marginRight)
              const value = p.map(i, 0, numXTicks, xMin, xMax)

              p.stroke(100)
              p.line(x, height - marginBottom, x, height - marginBottom + 5)

              p.noStroke()
              p.text(value.toFixed(1), x, height - marginBottom + 8)
            }

            // Y-axis ticks
            p.textAlign(p.RIGHT, p.CENTER)
            const numYTicks = 6
            for (let i = 0; i <= numYTicks; i++) {
              const y = p.map(i, 0, numYTicks, height - marginBottom, marginTop)
              const value = p.map(i, 0, numYTicks, yMin, yMax)

              p.stroke(100)
              p.line(marginLeft - 5, y, marginLeft, y)

              p.noStroke()
              p.text(value.toFixed(1), marginLeft - 8, y)
            }
          }

          const drawGrid = () => {
            p.stroke(200)
            p.strokeWeight(0.5)

            // Vertical grid lines
            const numXTicks = 8
            for (let i = 1; i < numXTicks; i++) {
              const x = p.map(i, 0, numXTicks, marginLeft, width - marginRight)
              p.line(x, marginTop, x, height - marginBottom)
            }

            // Horizontal grid lines
            const numYTicks = 6
            for (let i = 1; i < numYTicks; i++) {
              const y = p.map(i, 0, numYTicks, height - marginBottom, marginTop)
              p.line(marginLeft, y, width - marginRight, y)
            }
          }

          const drawTrendLine = () => {
            if (!data?.points || data.points.length < 2) return

            const controls = controlsRef.current
            if (!controls.showTrendLine) return

            // Calculate linear regression
            const points = data.points
            const n = points.length

            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0

            for (let point of points) {
              sumX += point.x
              sumY += point.y
              sumXY += point.x * point.y
              sumXX += point.x * point.x
            }

            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)
            const intercept = (sumY - slope * sumX) / n

            // Draw trend line
            p.stroke(255, 100, 100)
            p.strokeWeight(2)

            const x1 = marginLeft
            const x2 = width - marginRight
            const y1 = p.map(slope * xMin + intercept, yMin, yMax, height - marginBottom, marginTop)
            const y2 = p.map(slope * xMax + intercept, yMin, yMax, height - marginBottom, marginTop)

            p.line(x1, y1, x2, y2)
          }

          const drawPoints = () => {
            if (!data?.points) return

            const controls = controlsRef.current

            p.fill(67, 126, 234, 180)
            p.stroke(67, 126, 234)
            p.strokeWeight(1)

            for (let point of data.points) {
              const x = p.map(point.x, xMin, xMax, marginLeft, width - marginRight)
              const y = p.map(point.y, yMin, yMax, height - marginBottom, marginTop)

              p.ellipse(x, y, controls.pointSize, controls.pointSize)
            }

            // Highlight hovered point
            if (hoveredPoint) {
              p.fill(255, 100, 100)
              p.stroke(200, 50, 50)
              p.strokeWeight(2)

              const x = p.map(hoveredPoint.x, xMin, xMax, marginLeft, width - marginRight)
              const y = p.map(hoveredPoint.y, yMin, yMax, height - marginBottom, marginTop)

              p.ellipse(x, y, controls.pointSize + 4, controls.pointSize + 4)

              // Draw tooltip
              drawTooltip(hoveredPoint, x, y)
            }
          }

          const drawTooltip = (point: any, x: number, y: number) => {
            const tooltipText = `${point.label || 'Point'}: (${point.x}, ${point.y})`

            p.fill(0, 0, 0, 180)
            p.noStroke()
            p.textAlign(p.LEFT, p.CENTER)
            p.textSize(10)

            const textW = p.textWidth(tooltipText) + 10
            const textH = 20

            // Position tooltip to avoid edges
            let tooltipX = x + 10
            let tooltipY = y - 10

            if (tooltipX + textW > width) tooltipX = x - textW - 10
            if (tooltipY < textH) tooltipY = y + 20

            p.rect(tooltipX, tooltipY - textH/2, textW, textH, 4)

            p.fill(255)
            p.text(tooltipText, tooltipX + 5, tooltipY)
          }

          const drawLabels = () => {
            p.fill(60)
            p.noStroke()
            p.textAlign(p.CENTER, p.CENTER)
            p.textSize(labelSize)

            // X-axis label
            const xLabel = data?.xLabel || 'X'
            p.text(xLabel, (marginLeft + width - marginRight) / 2, height - 25)

            // Y-axis label
            const yLabel = data?.yLabel || 'Y'
            p.push()
            p.translate(20, (marginTop + height - marginBottom) / 2)
            p.rotate(-p.PI/2)
            p.text(yLabel, 0, 0)
            p.pop()
          }

          const drawTitle = () => {
            const title = data?.title || 'Scatter Plot'
            p.fill(60)
            p.noStroke()
            p.textAlign(p.CENTER, p.CENTER)
            p.textSize(titleSize)
            p.text(title, width/2, 30)
          }

          const drawNoDataMessage = () => {
            p.fill(100)
            p.textAlign(p.CENTER, p.CENTER)
            p.textSize(16)
            p.text('Load data via URL parameter, file upload, or use demo data', width/2, height/2)
          }

          const getHoveredPoint = () => {
            if (!data?.points) return null

            const controls = controlsRef.current

            for (let point of data.points) {
              const x = p.map(point.x, xMin, xMax, marginLeft, width - marginRight)
              const y = p.map(point.y, yMin, yMax, height - marginBottom, marginTop)

              const distance = Math.sqrt((p.mouseX - x) ** 2 + (p.mouseY - y) ** 2)

              if (distance < controls.pointSize + 5) {
                return point
              }
            }

            return null
          }

          p.setup = () => {
            const canvas = p.createCanvas(width, height)
            canvas.parent(canvasRef.current)
            canvas.style('display', 'block')
            canvas.style('margin', '0 auto')

            p.textAlign(p.CENTER, p.CENTER)
            calculateRanges()
            p.noLoop() // Static visualization
          }

          p.draw = () => {
            p.background(250)

            if (!data?.points || data.points.length === 0) {
              drawNoDataMessage()
              return
            }

            drawGrid()
            drawAxes()
            drawTrendLine()
            drawPoints()
            drawLabels()
            drawTitle()
          }

          p.mouseMoved = () => {
            const newHoveredPoint = getHoveredPoint()
            if (newHoveredPoint !== hoveredPoint) {
              hoveredPoint = newHoveredPoint
              p.redraw()
            }
            return false
          }

          p.windowResized = () => {
            calculateRanges()
            p.redraw()
          }

          // Public method to trigger redraw
          ;(p as any).updateDisplay = () => {
            p.redraw()
          }
        }

        if (!isMounted) return

        p5 = new P5(sketch)

        if (isMounted) {
          setP5Instance(p5)
        }
      }
    }

    loadP5()

    return () => {
      isMounted = false
      if (p5) {
        p5.remove()
      }
      setP5Instance(null)
      if (canvasRef.current) {
        canvasRef.current.innerHTML = ''
      }
    }
  }, [data, width, height, onError])

  // Trigger redraw when controls change
  useEffect(() => {
    if (p5Instance && (p5Instance as any).updateDisplay) {
      ;(p5Instance as any).updateDisplay()
    }
  }, [pointSize, showTrendLine, p5Instance])

  return (
    <div className="flex flex-col items-center w-full gap-4">
      {/* Canvas */}
      <div ref={canvasRef} className="border border-gray-300 rounded-lg shadow-sm bg-white" />

      {/* Controls */}
      <div className="w-full max-w-4xl bg-white rounded-lg shadow-md p-6">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Point Size */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Point Size: <span className="text-blue-600">{pointSize}</span>
            </label>
            <input
              type="range"
              min="2"
              max="20"
              value={pointSize}
              onChange={(e) => setPointSize(parseInt(e.target.value))}
              className="w-full"
            />
          </div>

          {/* Trend Line Toggle */}
          <div className="flex items-center">
            <label className="flex items-center cursor-pointer">
              <input
                type="checkbox"
                checked={showTrendLine}
                onChange={(e) => setShowTrendLine(e.target.checked)}
                className="mr-2 w-4 h-4"
              />
              <span className="text-sm font-medium text-gray-700">
                Show Trend Line
              </span>
            </label>
          </div>
        </div>

        {/* Instructions */}
        <div className="mt-6 text-sm text-gray-600 space-y-1">
          <p><strong>Hover over points:</strong> View detailed information</p>
          <p><strong>Trend line:</strong> Shows linear regression fit</p>
          <p><strong>Data points:</strong> {data?.points?.length || 0} points loaded</p>
        </div>
      </div>
    </div>
  )
}
