'use client'

import { useEffect, useRef, useState } from 'react'
import type { ParticleSystemData, VisualizationProps } from '@/types'

interface ParticlesProps extends VisualizationProps {
  config?: ParticleSystemData
}

export default function Particles({
  config,
  width = 900,
  height = 600,
  onError
}: ParticlesProps) {
  const canvasRef = useRef<HTMLDivElement>(null)
  const [p5Instance, setP5Instance] = useState<any>(null)

  // Control states (these are controlled by UI, so they should be state)
  const [particleCount, setParticleCount] = useState(
    config?.parameters?.particleCount || 100
  )
  const [gravity, setGravity] = useState(
    config?.parameters?.gravity || 0.5
  )
  const [damping, setDamping] = useState(
    config?.parameters?.damping || 0.99
  )
  const [isPaused, setIsPaused] = useState(false)
  const [trailMode, setTrailMode] = useState(false)

  // Use refs for P5 to access latest state values without recreating sketch
  const controlsRef = useRef({ particleCount, gravity, damping, isPaused, trailMode })

  useEffect(() => {
    controlsRef.current = { particleCount, gravity, damping, isPaused, trailMode }
  }, [particleCount, gravity, damping, isPaused, trailMode])

  useEffect(() => {
    let p5: any
    let isMounted = true

    const loadP5 = async () => {
      if (typeof window !== 'undefined' && canvasRef.current) {
        // Clear any existing canvases
        if (canvasRef.current) {
          canvasRef.current.innerHTML = ''
        }

        const p5Module = await import('p5')
        const P5 = p5Module.default

        if (!isMounted) return

        const sketch = (p: any) => {
          // Get Vector class from p5 instance
          const Vector = (p as any).constructor.Vector

          // Particle class
          class Particle {
            pos: any
            vel: any
            acc: any
            size: number
            mass: number
            color: any
            trail: any[]
            maxTrailLength: number
            trailIndex: number

            constructor(x?: number, y?: number, vx = 0, vy = 0) {
              this.pos = p.createVector(
                x ?? p.random(width),
                y ?? p.random(height)
              )
              this.vel = p.createVector(
                vx || p.random(-2, 2),
                vy || p.random(-2, 2)
              )
              this.acc = p.createVector(0, 0)
              this.size = p.random(2, 6)
              this.mass = this.size * 0.1
              this.color = p.color(
                p.random(100, 255),
                p.random(100, 255),
                p.random(100, 255),
                180
              )
              this.trail = []
              this.maxTrailLength = 20
              this.trailIndex = 0
            }

            applyForce(force: any) {
              const f = Vector.div(force, this.mass)
              this.acc.add(f)
            }

            update(mouseAttraction: boolean) {
              const controls = controlsRef.current
              if (controls.isPaused) return

              // Apply gravity
              const gravityForce = p.createVector(0, controls.gravity * this.mass)
              this.applyForce(gravityForce)

              // Apply mouse attraction/repulsion
              if (mouseAttraction && p.mouseIsPressed) {
                const mousePos = p.createVector(p.mouseX, p.mouseY)
                const force = Vector.sub(mousePos, this.pos)
                const distance = force.mag()

                if (distance > 0 && distance < 200) {
                  force.normalize()
                  force.mult(50 / (distance * 0.1))

                  // Repel if right mouse button
                  if (p.mouseButton === p.RIGHT) {
                    force.mult(-1)
                  }

                  this.applyForce(force)
                }
              }

              // Update kinematics
              this.vel.add(this.acc)
              this.vel.mult(controls.damping)
              this.pos.add(this.vel)
              this.acc.mult(0)

              // Boundary collisions
              this.handleBoundaries()

              // Update trail
              if (controls.trailMode) {
                this.trail[this.trailIndex % this.maxTrailLength] = this.pos.copy()
                this.trailIndex++
              }
            }

            handleBoundaries() {
              const BOUNCE_DAMPING = 0.8

              // Floor
              if (this.pos.y > height - this.size / 2) {
                this.pos.y = height - this.size / 2
                this.vel.y *= -BOUNCE_DAMPING
              }

              // Ceiling
              if (this.pos.y < this.size / 2) {
                this.pos.y = this.size / 2
                this.vel.y *= -BOUNCE_DAMPING
              }

              // Walls
              if (this.pos.x > width - this.size / 2) {
                this.pos.x = width - this.size / 2
                this.vel.x *= -BOUNCE_DAMPING
              }

              if (this.pos.x < this.size / 2) {
                this.pos.x = this.size / 2
                this.vel.x *= -BOUNCE_DAMPING
              }
            }

            display() {
              const controls = controlsRef.current

              // Draw trail
              if (controls.trailMode && this.trail.length > 1) {
                p.stroke(p.red(this.color), p.green(this.color), p.blue(this.color), 100)
                p.strokeWeight(1)
                p.noFill()

                p.beginShape()
                for (let pos of this.trail) {
                  p.vertex(pos.x, pos.y)
                }
                p.endShape()
              }

              // Draw particle
              p.fill(this.color)
              p.noStroke()
              p.ellipse(this.pos.x, this.pos.y, this.size, this.size)

              // Glow effect
              p.fill(p.red(this.color), p.green(this.color), p.blue(this.color), 50)
              p.ellipse(this.pos.x, this.pos.y, this.size * 2, this.size * 2)
            }

            collidesWith(other: Particle) {
              const distance = Vector.dist(this.pos, other.pos)
              return distance < (this.size + other.size) / 2
            }

            resolveCollision(other: Particle) {
              const distance = Vector.dist(this.pos, other.pos)
              const minDistance = (this.size + other.size) / 2

              if (distance < minDistance) {
                const normal = Vector.sub(other.pos, this.pos)
                normal.normalize()

                // Separate particles
                const overlap = minDistance - distance
                const separation = Vector.mult(normal, overlap / 2)

                this.pos.sub(separation)
                other.pos.add(separation)

                // Calculate collision response
                const relativeVel = Vector.sub(other.vel, this.vel)
                const velAlongNormal = Vector.dot(relativeVel, normal)

                if (velAlongNormal > 0) return

                const restitution = 0.8
                const impulse = -(1 + restitution) * velAlongNormal / (1/this.mass + 1/other.mass)

                const impulseVector = Vector.mult(normal, impulse)

                this.vel.sub(Vector.div(impulseVector, this.mass))
                other.vel.add(Vector.div(impulseVector, other.mass))
              }
            }
          }

          // Sketch state
          let particles: Particle[] = []
          let mouseAttraction = false
          const GRID_CELL_SIZE = 50

          // Spatial grid functions
          const getGridKey = (x: number, y: number) => {
            const gridX = Math.floor(x / GRID_CELL_SIZE)
            const gridY = Math.floor(y / GRID_CELL_SIZE)
            return `${gridX},${gridY}`
          }

          const buildSpatialGrid = () => {
            const grid: Record<string, Particle[]> = {}
            for (let particle of particles) {
              const key = getGridKey(particle.pos.x, particle.pos.y)
              if (!grid[key]) {
                grid[key] = []
              }
              grid[key].push(particle)
            }
            return grid
          }

          const getNearbyParticles = (particle: Particle, grid: Record<string, Particle[]>) => {
            const nearby: Particle[] = []
            const gridX = Math.floor(particle.pos.x / GRID_CELL_SIZE)
            const gridY = Math.floor(particle.pos.y / GRID_CELL_SIZE)

            for (let dx = -1; dx <= 1; dx++) {
              for (let dy = -1; dy <= 1; dy++) {
                const key = `${gridX + dx},${gridY + dy}`
                if (grid[key]) {
                  nearby.push(...grid[key])
                }
              }
            }
            return nearby
          }

          const resetParticles = () => {
            const controls = controlsRef.current
            particles = []

            for (let i = 0; i < controls.particleCount; i++) {
              const x = p.random(50, width - 50)
              const y = p.random(-100, 50)
              const vx = p.random(-1, 1)
              const vy = p.random(0, 2)

              particles.push(new Particle(x, y, vx, vy))
            }
          }

          p.setup = () => {
            const canvas = p.createCanvas(width, height)
            canvas.parent(canvasRef.current)
            canvas.style('display', 'block')
            canvas.style('margin', '0 auto')

            resetParticles()
          }

          p.draw = () => {
            const controls = controlsRef.current

            // Background with fade for trails
            if (controls.trailMode) {
              p.fill(0, 0, 0, 20)
              p.noStroke()
              p.rect(0, 0, width, height)
            } else {
              p.background(20)
            }

            // Update particles
            for (let particle of particles) {
              particle.update(mouseAttraction)
            }

            // Build spatial grid
            const spatialGrid = buildSpatialGrid()

            // Check collisions using spatial grid
            const checkedPairs = new Set<string>()
            for (let i = 0; i < particles.length; i++) {
              const particle = particles[i]
              const nearby = getNearbyParticles(particle, spatialGrid)

              for (let other of nearby) {
                if (particle === other) continue

                const pairId = i < particles.indexOf(other)
                  ? `${i}-${particles.indexOf(other)}`
                  : `${particles.indexOf(other)}-${i}`

                if (checkedPairs.has(pairId)) continue
                checkedPairs.add(pairId)

                if (particle.collidesWith(other)) {
                  particle.resolveCollision(other)
                }
              }
            }

            // Display particles
            for (let particle of particles) {
              particle.display()
            }

            // Draw mouse influence area
            if (mouseAttraction && p.mouseIsPressed) {
              p.stroke(255, 100)
              p.strokeWeight(1)
              p.noFill()
              p.ellipse(p.mouseX, p.mouseY, 200, 200)
            }

            // Draw UI
            p.fill(255, 200)
            p.noStroke()
            p.textAlign(p.LEFT, p.TOP)
            p.textSize(10)

            const fps = Math.round(p.frameRate())
            p.text(`FPS: ${fps}`, 10, 10)
            p.text(`Particles: ${particles.length}`, 10, 25)
            p.text(`Gravity: ${controls.gravity.toFixed(1)}`, 10, 40)
            p.text(`Damping: ${controls.damping.toFixed(2)}`, 10, 55)

            if (controls.isPaused) {
              p.textAlign(p.CENTER, p.CENTER)
              p.textSize(24)
              p.fill(255, 0, 0, 150)
              p.text('PAUSED', width/2, height/2)
            }
          }

          p.mousePressed = () => {
            mouseAttraction = true
            return false
          }

          p.mouseReleased = () => {
            mouseAttraction = false
            return false
          }

          p.keyPressed = () => {
            switch (p.key.toLowerCase()) {
              case 't':
                setTrailMode(prev => !prev)
                if (!controlsRef.current.trailMode) {
                  particles.forEach((particle: Particle) => {
                    particle.trail = []
                    particle.trailIndex = 0
                  })
                }
                break
              case ' ':
                setIsPaused(prev => !prev)
                break
              case 'r':
                resetParticles()
                break
              case 'm':
                mouseAttraction = !mouseAttraction
                break
            }
            return false
          }

          // Public method to reset particles from controls
          ;(p as any).resetParticles = resetParticles
        }

        if (!isMounted) return

        p5 = new P5(sketch)

        if (isMounted) {
          setP5Instance(p5)
        }
      }
    }

    loadP5()

    return () => {
      isMounted = false
      if (p5) {
        p5.remove()
      }
      setP5Instance(null)
      if (canvasRef.current) {
        canvasRef.current.innerHTML = ''
      }
    }
  }, [width, height, onError])

  // Reset particles when particle count changes
  useEffect(() => {
    if (p5Instance && (p5Instance as any).resetParticles) {
      ;(p5Instance as any).resetParticles()
    }
  }, [particleCount, p5Instance])

  return (
    <div className="flex flex-col items-center w-full gap-4">
      {/* Canvas */}
      <div ref={canvasRef} className="border border-gray-300 rounded-lg shadow-sm bg-black" />

      {/* Controls */}
      <div className="w-full max-w-4xl bg-white rounded-lg shadow-md p-6">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
          {/* Particle Count */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Particle Count: <span className="text-blue-600">{particleCount}</span>
            </label>
            <input
              type="range"
              min="10"
              max="500"
              value={particleCount}
              onChange={(e) => setParticleCount(parseInt(e.target.value))}
              className="w-full"
            />
          </div>

          {/* Gravity */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Gravity: <span className="text-blue-600">{gravity.toFixed(1)}</span>
            </label>
            <input
              type="range"
              min="0"
              max="20"
              step="1"
              value={gravity * 10}
              onChange={(e) => setGravity(parseFloat(e.target.value) / 10)}
              className="w-full"
            />
          </div>

          {/* Damping */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Damping: <span className="text-blue-600">{damping.toFixed(2)}</span>
            </label>
            <input
              type="range"
              min="90"
              max="100"
              step="1"
              value={damping * 100}
              onChange={(e) => setDamping(parseFloat(e.target.value) / 100)}
              className="w-full"
            />
          </div>
        </div>

        {/* Buttons */}
        <div className="flex flex-wrap gap-3 mt-6">
          <button
            onClick={() => setIsPaused(!isPaused)}
            className="btn px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            {isPaused ? 'Resume' : 'Pause'}
          </button>
          <button
            onClick={() => setTrailMode(!trailMode)}
            className={`btn px-4 py-2 rounded ${
              trailMode
                ? 'bg-green-500 text-white hover:bg-green-600'
                : 'bg-gray-300 text-gray-700 hover:bg-gray-400'
            }`}
          >
            Trail Mode {trailMode ? 'ON' : 'OFF'}
          </button>
          <button
            onClick={() => {
              if (p5Instance && (p5Instance as any).resetParticles) {
                ;(p5Instance as any).resetParticles()
              }
            }}
            className="btn px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
          >
            Reset
          </button>
        </div>

        {/* Instructions */}
        <div className="mt-6 text-sm text-gray-600 space-y-1">
          <p><strong>Click and drag:</strong> Attract particles</p>
          <p><strong>Right click:</strong> Repel particles</p>
          <p><strong>T:</strong> Toggle trail mode</p>
          <p><strong>Space:</strong> Pause/Resume</p>
          <p><strong>R:</strong> Reset particles</p>
        </div>
      </div>
    </div>
  )
}
