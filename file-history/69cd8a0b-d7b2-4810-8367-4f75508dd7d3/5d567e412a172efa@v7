'use client'

import { useEffect, useRef, useState } from 'react'
import type { VectorFieldData, VectorFieldTrajectory, VisualizationProps } from '@/types'

interface VectorFieldProps extends VisualizationProps {
  data: VectorFieldData
}

export default function VectorField({
  data,
  width = 1200,
  height = 800,
  onError
}: VectorFieldProps) {
  const canvasRef = useRef<HTMLDivElement>(null)
  const [p5Instance, setP5Instance] = useState<any>(null)
  const [trajectories, setTrajectories] = useState<VectorFieldTrajectory[]>([])
  const [currentTimeIndex, setCurrentTimeIndex] = useState(0)
  const currentTimeIndexRef = useRef(0)
  const [isPlaying, setIsPlaying] = useState(false)
  const [showArrows, setShowArrows] = useState(true)
  const [gridDensity] = useState(20)
  const [bounds, setBounds] = useState<{ min: number[], max: number[] } | null>(null)

  // Initial condition inputs for 3D
  const [ic3DX, setIc3DX] = useState('1.0')
  const [ic3DY, setIc3DY] = useState('1.0')
  const [ic3DZ, setIc3DZ] = useState('1.0')

  // Simulation time control (5-60 seconds)
  const [simulationTime, setSimulationTime] = useState(20)

  // Sync state to ref
  useEffect(() => {
    currentTimeIndexRef.current = currentTimeIndex
  }, [currentTimeIndex])

  // Calculate bounds when data changes
  useEffect(() => {
    if (!data) return

    if (data.bounds) {
      setBounds(data.bounds)
    } else {
      // Auto-calculate bounds based on system characteristics
      const calculatedBounds = calculateBounds(data)
      setBounds(calculatedBounds)
    }
  }, [data])

  // Auto-play animation
  useEffect(() => {
    if (!isPlaying || trajectories.length === 0) return

    const maxLength = Math.max(...trajectories.map(t => t.t.length))
    if (currentTimeIndex >= maxLength - 1) {
      setIsPlaying(false)
      return
    }

    const interval = setInterval(() => {
      setCurrentTimeIndex((prev) => {
        const next = prev + 1
        if (next >= maxLength) {
          setIsPlaying(false)
          return prev
        }
        return next
      })
    }, 50)

    return () => clearInterval(interval)
  }, [isPlaying, trajectories, currentTimeIndex])

  // P5.js visualization
  useEffect(() => {
    let p5: any
    let isMounted = true

    const loadP5 = async () => {
      if (typeof window !== 'undefined' && canvasRef.current && bounds) {
        canvasRef.current.innerHTML = ''

        const p5Module = await import('p5')
        const P5 = p5Module.default

        if (!isMounted) return

        const is3D = data.dimension === 3

        const sketch = (p: any) => {
          p.setup = () => {
            const canvas = is3D
              ? p.createCanvas(width, height - 150, p.WEBGL)
              : p.createCanvas(width, height - 150)
            canvas.parent(canvasRef.current)
            canvas.style('display', 'block')
            canvas.style('margin', '0 auto')

            p.textAlign(p.CENTER, p.CENTER)
            p.frameRate(30)
          }

          p.draw = () => {
            p.background(250)

            if (is3D) {
              draw3D(p)
            } else {
              draw2D(p)
            }
          }

          function draw2D(p: any) {
            const selectedStates = data.selectedStates || [0, 1]
            const stateX = selectedStates[0]
            const stateY = selectedStates[1]

            const xMin = bounds!.min[stateX]
            const xMax = bounds!.max[stateX]
            const yMin = bounds!.min[stateY]
            const yMax = bounds!.max[stateY]

            // Map function from state space to canvas
            const mapX = (x: number) => p.map(x, xMin, xMax, 50, width - 50)
            const mapY = (y: number) => p.map(y, yMin, yMax, height - 200, 50)

            // Draw axes
            p.stroke(200)
            p.strokeWeight(1)
            p.line(50, mapY(0), width - 50, mapY(0)) // X-axis
            p.line(mapX(0), 50, mapX(0), height - 200) // Y-axis

            // Draw border
            p.stroke(100)
            p.noFill()
            p.rect(50, 50, width - 100, height - 250)

            // Draw vector field
            if (showArrows) {
              drawVectorField2D(p, mapX, mapY, stateX, stateY, xMin, xMax, yMin, yMax)
            }

            // Draw trajectories
            trajectories.forEach((traj, idx) => {
              drawTrajectory2D(p, traj, mapX, mapY, stateX, stateY, idx)
            })

            // Draw labels
            const labelX = data.labels?.[stateX] || `x${stateX + 1}`
            const labelY = data.labels?.[stateY] || `x${stateY + 1}`

            p.fill(60)
            p.noStroke()
            p.textSize(14)
            p.textAlign(p.CENTER, p.TOP)
            p.text(labelX, width / 2, height - 180)

            p.push()
            p.translate(20, height / 2 - 100)
            p.rotate(-p.HALF_PI)
            p.textAlign(p.CENTER, p.TOP)
            p.text(labelY, 0, 0)
            p.pop()

            // Title
            if (data.title) {
              p.fill(60)
              p.textSize(18)
              p.textAlign(p.CENTER, p.TOP)
              p.text(data.title, width / 2, 10)
            }

            // Color legend
            if (showArrows) {
              drawColorLegend(p)
            }
          }

          function draw3D(p: any) {
            // 3D rendering
            p.orbitControl()

            const selectedStates = data.selectedStates || [0, 1, 2]
            const stateX = selectedStates[0]
            const stateY = selectedStates[1]
            const stateZ = selectedStates[2]

            const xMin = bounds!.min[stateX]
            const xMax = bounds!.max[stateX]
            const yMin = bounds!.min[stateY]
            const yMax = bounds!.max[stateY]
            const zMin = bounds!.min[stateZ]
            const zMax = bounds!.max[stateZ]

            const scale = 100

            // Map function
            const mapVal = (val: number, min: number, max: number) =>
              p.map(val, min, max, -scale, scale)

            // Draw axes
            p.stroke(200, 0, 0)
            p.strokeWeight(2)
            p.line(-scale, 0, 0, scale, 0, 0) // X-axis

            p.stroke(0, 200, 0)
            p.line(0, -scale, 0, 0, scale, 0) // Y-axis

            p.stroke(0, 0, 200)
            p.line(0, 0, -scale, 0, 0, scale) // Z-axis

            // Draw vector field
            if (showArrows) {
              drawVectorField3D(p, mapVal, stateX, stateY, stateZ, xMin, xMax, yMin, yMax, zMin, zMax, scale)
            }

            // Draw trajectories
            trajectories.forEach((traj, idx) => {
              drawTrajectory3D(p, traj, mapVal, stateX, stateY, stateZ, idx)
            })
          }

          function drawColorLegend(p: any) {
            // Draw color legend in bottom-right corner
            const legendX = width - 150
            const legendY = height - 160
            const legendWidth = 120
            const legendHeight = 20

            // Draw gradient bar
            p.noStroke()
            for (let i = 0; i < legendWidth; i++) {
              const t = i / legendWidth
              const [r, g, b] = magnitudeToColor(t, 1)
              p.fill(r, g, b)
              p.rect(legendX + i, legendY, 1, legendHeight)
            }

            // Draw border
            p.stroke(60)
            p.strokeWeight(1)
            p.noFill()
            p.rect(legendX, legendY, legendWidth, legendHeight)

            // Draw labels
            p.fill(60)
            p.noStroke()
            p.textSize(11)
            p.textAlign(p.LEFT, p.CENTER)
            p.text('Low', legendX, legendY - 10)
            p.textAlign(p.RIGHT, p.CENTER)
            p.text('High', legendX + legendWidth, legendY - 10)
            p.textAlign(p.CENTER, p.TOP)
            p.text('Magnitude', legendX + legendWidth / 2, legendY + legendHeight + 5)
          }

          function drawVectorField2D(
            p: any,
            mapX: Function,
            mapY: Function,
            stateX: number,
            stateY: number,
            xMin: number,
            xMax: number,
            yMin: number,
            yMax: number
          ) {
            const density = gridDensity
            const dx = (xMax - xMin) / density
            const dy = (yMax - yMin) / density

            // Calculate max magnitude for normalization
            let maxMag = 0
            for (let i = 0; i <= density; i++) {
              for (let j = 0; j <= density; j++) {
                const x = xMin + i * dx
                const y = yMin + j * dy
                const state = buildFullState(x, y, 0, stateX, stateY, 0)
                const dState = evaluateSystem(state)
                const mag = Math.sqrt(dState[stateX] ** 2 + dState[stateY] ** 2)
                maxMag = Math.max(maxMag, mag)
              }
            }

            // Draw arrows
            for (let i = 0; i <= density; i++) {
              for (let j = 0; j <= density; j++) {
                const x = xMin + i * dx
                const y = yMin + j * dy

                const state = buildFullState(x, y, 0, stateX, stateY, 0)
                const dState = evaluateSystem(state)

                const vx = dState[stateX]
                const vy = dState[stateY]
                const mag = Math.sqrt(vx ** 2 + vy ** 2)

                if (mag < 0.001) continue

                // Normalize for display
                const normVx = vx / mag
                const normVy = vy / mag
                const arrowLen = 15

                const px = mapX(x)
                const py = mapY(y)
                const ex = px + normVx * arrowLen
                const ey = py - normVy * arrowLen // Flip Y for canvas

                // Color by magnitude
                const color = magnitudeToColor(mag, maxMag)
                p.stroke(color)
                p.strokeWeight(1.5)
                p.line(px, py, ex, ey)

                // Arrowhead
                const angle = Math.atan2(-normVy, normVx)
                const arrowSize = 4
                p.fill(color)
                p.noStroke()
                p.push()
                p.translate(ex, ey)
                p.rotate(angle)
                p.triangle(0, 0, -arrowSize, -arrowSize / 2, -arrowSize, arrowSize / 2)
                p.pop()
              }
            }
          }

          function drawVectorField3D(
            p: any,
            mapVal: Function,
            stateX: number,
            stateY: number,
            stateZ: number,
            xMin: number,
            xMax: number,
            yMin: number,
            yMax: number,
            zMin: number,
            zMax: number,
            scale: number
          ) {
            const density = Math.min(gridDensity, 12) // Limit for 3D performance
            const dx = (xMax - xMin) / density
            const dy = (yMax - yMin) / density
            const dz = (zMax - zMin) / density

            // Calculate max magnitude
            let maxMag = 0
            for (let i = 0; i <= density; i++) {
              for (let j = 0; j <= density; j++) {
                for (let k = 0; k <= density; k++) {
                  const x = xMin + i * dx
                  const y = yMin + j * dy
                  const z = zMin + k * dz
                  const state = buildFullState(x, y, z, stateX, stateY, stateZ)
                  const dState = evaluateSystem(state)
                  const mag = Math.sqrt(dState[stateX] ** 2 + dState[stateY] ** 2 + dState[stateZ] ** 2)
                  maxMag = Math.max(maxMag, mag)
                }
              }
            }

            // Draw arrows
            p.strokeWeight(1)
            for (let i = 0; i <= density; i++) {
              for (let j = 0; j <= density; j++) {
                for (let k = 0; k <= density; k++) {
                  const x = xMin + i * dx
                  const y = yMin + j * dy
                  const z = zMin + k * dz

                  const state = buildFullState(x, y, z, stateX, stateY, stateZ)
                  const dState = evaluateSystem(state)

                  const vx = dState[stateX]
                  const vy = dState[stateY]
                  const vz = dState[stateZ]
                  const mag = Math.sqrt(vx ** 2 + vy ** 2 + vz ** 2)

                  if (mag < 0.001) continue

                  // Normalize
                  const normVx = vx / mag
                  const normVy = vy / mag
                  const normVz = vz / mag
                  const arrowLen = scale / 8

                  const px = mapVal(x, xMin, xMax)
                  const py = mapVal(y, yMin, yMax)
                  const pz = mapVal(z, zMin, zMax)

                  const ex = px + normVx * arrowLen
                  const ey = py + normVy * arrowLen
                  const ez = pz + normVz * arrowLen

                  // Color by magnitude
                  const color = magnitudeToColor(mag, maxMag)
                  p.stroke(color)
                  p.line(px, py, pz, ex, ey, ez)
                }
              }
            }
          }

          function drawTrajectory2D(
            p: any,
            traj: VectorFieldTrajectory,
            mapX: Function,
            mapY: Function,
            stateX: number,
            stateY: number,
            idx: number
          ) {
            const currentIdx = currentTimeIndexRef.current
            const color = traj.color

            // Draw trail
            p.stroke(color)
            p.strokeWeight(2)
            p.noFill()
            p.beginShape()
            for (let i = 0; i <= Math.min(currentIdx, traj.points.length - 1); i++) {
              const point = traj.points[i]
              const px = mapX(point[stateX])
              const py = mapY(point[stateY])
              p.vertex(px, py)
            }
            p.endShape()

            // Draw current point
            if (currentIdx < traj.points.length) {
              const point = traj.points[currentIdx]
              const px = mapX(point[stateX])
              const py = mapY(point[stateY])

              p.fill(color)
              p.noStroke()
              p.circle(px, py, 10)
            }

            // Draw starting point
            if (traj.points.length > 0) {
              const start = traj.points[0]
              const px = mapX(start[stateX])
              const py = mapY(start[stateY])

              p.fill(100, 255, 100)
              p.noStroke()
              p.circle(px, py, 8)
            }
          }

          function drawTrajectory3D(
            p: any,
            traj: VectorFieldTrajectory,
            mapVal: Function,
            stateX: number,
            stateY: number,
            stateZ: number,
            idx: number
          ) {
            const currentIdx = currentTimeIndexRef.current
            const color = traj.color

            // Draw trail
            p.stroke(color)
            p.strokeWeight(2)
            p.noFill()
            p.beginShape()
            for (let i = 0; i <= Math.min(currentIdx, traj.points.length - 1); i++) {
              const point = traj.points[i]
              const px = mapVal(point[stateX], bounds!.min[stateX], bounds!.max[stateX])
              const py = mapVal(point[stateY], bounds!.min[stateY], bounds!.max[stateY])
              const pz = mapVal(point[stateZ], bounds!.min[stateZ], bounds!.max[stateZ])
              p.vertex(px, py, pz)
            }
            p.endShape()

            // Draw current point
            if (currentIdx < traj.points.length) {
              const point = traj.points[currentIdx]
              const px = mapVal(point[stateX], bounds!.min[stateX], bounds!.max[stateX])
              const py = mapVal(point[stateY], bounds!.min[stateY], bounds!.max[stateY])
              const pz = mapVal(point[stateZ], bounds!.min[stateZ], bounds!.max[stateZ])

              p.push()
              p.translate(px, py, pz)
              p.fill(color)
              p.noStroke()
              p.sphere(5)
              p.pop()
            }
          }

          function buildFullState(
            val1: number,
            val2: number,
            val3: number,
            idx1: number,
            idx2: number,
            idx3: number
          ): number[] {
            const n = data.A?.length || 3
            const state = new Array(n).fill(0)

            // Set fixed states based on mode
            if (data.otherStatesMode === 'custom' && data.otherStatesValues) {
              for (let i = 0; i < n; i++) {
                state[i] = data.otherStatesValues[i] || 0
              }
            }
            // TODO: Add equilibrium mode

            // Set selected states
            state[idx1] = val1
            state[idx2] = val2
            if (data.dimension === 3 && idx3 < n) {
              state[idx3] = val3
            }

            return state
          }

          function evaluateSystem(state: number[]): number[] {
            if (data.f) {
              // Nonlinear system
              return data.f(state)
            } else if (data.A) {
              // Linear system: dx/dt = Ax
              const n = state.length
              const dState = new Array(n).fill(0)
              for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                  dState[i] += data.A[i][j] * state[j]
                }
              }
              return dState
            }
            return new Array(state.length).fill(0)
          }

          function magnitudeToColor(mag: number, maxMag: number): [number, number, number] {
            // Map magnitude to color (blue = low, red = high)
            const normalized = Math.min(mag / (maxMag || 1), 1)
            const r = Math.floor(normalized * 255)
            const b = Math.floor((1 - normalized) * 255)
            return [r, 100, b]
          }

          // Mouse click to add trajectory
          p.mousePressed = () => {
            if (!is3D && p.mouseX > 50 && p.mouseX < width - 50 && p.mouseY > 50 && p.mouseY < height - 200) {
              addTrajectoryFromClick(p)
              return false
            }
          }

          function addTrajectoryFromClick(p: any) {
            if (trajectories.length >= 2) return // Max 2 trajectories

            const selectedStates = data.selectedStates || [0, 1]
            const stateX = selectedStates[0]
            const stateY = selectedStates[1]

            const xMin = bounds!.min[stateX]
            const xMax = bounds!.max[stateX]
            const yMin = bounds!.min[stateY]
            const yMax = bounds!.max[stateY]

            const mapX = (x: number) => p.map(x, xMin, xMax, 50, width - 50)
            const mapY = (y: number) => p.map(y, yMin, yMax, height - 200, 50)

            // Inverse map (note: y-axis is inverted for mathematical convention)
            const x = p.map(p.mouseX, 50, width - 50, xMin, xMax)
            const y = p.map(p.mouseY, height - 200, 50, yMin, yMax)

            // Build initial condition
            const n = data.A?.length || 2
            const x0 = new Array(n).fill(0)
            x0[stateX] = x
            x0[stateY] = y

            // Integrate trajectory
            const traj = integrateTrajectory(x0)
            setTrajectories(prev => [...prev, traj])
            setCurrentTimeIndex(0)
          }

          function integrateTrajectory(x0: number[]): VectorFieldTrajectory {
            const dt = 0.05
            const tMax = simulationTime
            const steps = Math.floor(tMax / dt)

            const t: number[] = []
            const points: number[][] = []

            let x = [...x0]

            for (let i = 0; i < steps; i++) {
              t.push(i * dt)
              points.push([...x])

              // RK4 integration
              const k1 = evaluateSystem(x)
              const k2 = evaluateSystem(x.map((xi, j) => xi + 0.5 * dt * k1[j]))
              const k3 = evaluateSystem(x.map((xi, j) => xi + 0.5 * dt * k2[j]))
              const k4 = evaluateSystem(x.map((xi, j) => xi + dt * k3[j]))

              x = x.map((xi, j) => xi + (dt / 6) * (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]))
            }

            const colors = ['rgb(100,150,255)', 'rgb(255,100,150)']
            const color = colors[trajectories.length % colors.length]

            return {
              id: Date.now().toString(),
              x0,
              points,
              t,
              color
            }
          }
        }

        p5 = new P5(sketch)
        setP5Instance(p5)
      }
    }

    loadP5()

    return () => {
      isMounted = false
      if (p5) {
        p5.remove()
      }
    }
  }, [data, width, height, bounds, showArrows, gridDensity, trajectories])

  const handlePlayPause = () => {
    if (trajectories.length === 0) return

    const maxLength = Math.max(...trajectories.map(t => t.t.length))
    if (currentTimeIndex >= maxLength - 1) {
      setCurrentTimeIndex(0)
      setIsPlaying(true)
    } else {
      setIsPlaying(!isPlaying)
    }
  }

  const handleReset = () => {
    setCurrentTimeIndex(0)
    setIsPlaying(false)
  }

  const handleClearTrajectories = () => {
    setTrajectories([])
    setCurrentTimeIndex(0)
    setIsPlaying(false)
  }

  const handleAdd3DTrajectory = () => {
    if (trajectories.length >= 2) {
      alert('Maximum 2 trajectories allowed')
      return
    }

    if (!bounds) return

    // Parse input values
    const x = parseFloat(ic3DX)
    const y = parseFloat(ic3DY)
    const z = parseFloat(ic3DZ)

    // Validate
    if (isNaN(x) || isNaN(y) || isNaN(z)) {
      alert('Please enter valid numbers for all coordinates')
      return
    }

    // Check bounds
    const selectedStates = data.selectedStates || [0, 1, 2]
    const xMin = bounds.min[selectedStates[0]]
    const xMax = bounds.max[selectedStates[0]]
    const yMin = bounds.min[selectedStates[1]]
    const yMax = bounds.max[selectedStates[1]]
    const zMin = bounds.min[selectedStates[2]]
    const zMax = bounds.max[selectedStates[2]]

    if (x < xMin || x > xMax || y < yMin || y > yMax || z < zMin || z > zMax) {
      alert(`Coordinates out of bounds! Please use values within:\nx: [${xMin.toFixed(1)}, ${xMax.toFixed(1)}]\ny: [${yMin.toFixed(1)}, ${yMax.toFixed(1)}]\nz: [${zMin.toFixed(1)}, ${zMax.toFixed(1)}]`)
      return
    }

    // Build full state vector
    const n = data.A?.length || 3
    const fullState = new Array(n).fill(0)
    fullState[selectedStates[0]] = x
    fullState[selectedStates[1]] = y
    fullState[selectedStates[2]] = z

    // Integrate trajectory using RK4
    const dt = 0.05
    const tMax = simulationTime
    const steps = Math.floor(tMax / dt)

    const t: number[] = []
    const points: number[][] = []
    let state = [...fullState]

    // System dynamics function
    const evaluateSystem = (s: number[]): number[] => {
      if (data.f) {
        return data.f(s)
      }
      if (data.A) {
        const n = data.A.length
        const dState = new Array(n).fill(0)
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            dState[i] += data.A[i][j] * s[j]
          }
        }
        return dState
      }
      return new Array(s.length).fill(0)
    }

    for (let i = 0; i < steps; i++) {
      t.push(i * dt)
      points.push([...state])

      // RK4 integration
      const k1 = evaluateSystem(state)
      const k2 = evaluateSystem(state.map((si, j) => si + 0.5 * dt * k1[j]))
      const k3 = evaluateSystem(state.map((si, j) => si + 0.5 * dt * k2[j]))
      const k4 = evaluateSystem(state.map((si, j) => si + dt * k3[j]))

      state = state.map((si, j) => si + (dt / 6) * (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]))
    }

    const colors = ['rgb(100,150,255)', 'rgb(255,100,150)']
    const color = colors[trajectories.length % colors.length]

    const trajectory: VectorFieldTrajectory = {
      id: Date.now().toString(),
      x0: fullState,
      points,
      t,
      color
    }

    setTrajectories(prev => [...prev, trajectory])
    setCurrentTimeIndex(0)
  }

  const handleScrub = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value)
    setCurrentTimeIndex(value)
  }

  const maxTimeSteps = trajectories.length > 0
    ? Math.max(...trajectories.map(t => t.t.length))
    : 0

  return (
    <div className="w-full">
      <div ref={canvasRef} />

      {/* Controls */}
      <div className="mt-4 p-4 bg-gray-100 rounded-lg">
        {/* Display options */}
        <div className="flex items-center justify-center gap-4 mb-4 pb-3 border-b border-gray-300">
          <button
            onClick={() => setShowArrows(!showArrows)}
            className={`px-4 py-2 rounded transition-colors ${
              showArrows ? 'bg-blue-500 text-white' : 'bg-gray-300'
            }`}
          >
            {showArrows ? '✓ Arrows' : 'Arrows'}
          </button>

          <button
            onClick={handleClearTrajectories}
            className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600 transition-colors"
            disabled={trajectories.length === 0}
          >
            Clear Trajectories ({trajectories.length}/2)
          </button>

          <div className="flex items-center gap-2">
            <label className="text-sm font-medium">
              Sim Time: {simulationTime}s
            </label>
            <input
              type="range"
              min="5"
              max="60"
              step="5"
              value={simulationTime}
              onChange={(e) => setSimulationTime(parseInt(e.target.value))}
              className="w-32"
              title="Simulation time (5-60 seconds)"
            />
          </div>
        </div>

        {/* Playback controls */}
        {trajectories.length > 0 && (
          <>
            <div className="flex items-center justify-center gap-4 mb-3">
              <button
                onClick={handleReset}
                className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
              >
                Reset
              </button>

              <button
                onClick={handlePlayPause}
                className="px-6 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors font-semibold"
              >
                {isPlaying ? 'Pause' : 'Play'}
              </button>
            </div>

            {/* Timeline scrubber */}
            <div className="w-full">
              <input
                type="range"
                min={0}
                max={maxTimeSteps - 1}
                value={currentTimeIndex}
                onChange={handleScrub}
                className="w-full"
              />
              <div className="flex justify-between text-xs text-gray-600 mt-1">
                <span>t = 0s</span>
                {trajectories.length > 0 && (
                  <span>
                    t = {trajectories[0].t[Math.min(currentTimeIndex, trajectories[0].t.length - 1)]?.toFixed(2) || 0}s
                  </span>
                )}
              </div>
            </div>
          </>
        )}

        {data.dimension === 2 ? (
          <div className="mt-4 text-sm text-gray-600 text-center">
            Click on the vector field to add a trajectory (max 2)
          </div>
        ) : (
          <>
            {showArrows && (
              <div className="mt-4 text-xs text-gray-600 text-center pb-2">
                Vector colors: <span className="text-blue-600 font-semibold">Blue</span> = Low magnitude, <span className="text-red-600 font-semibold">Red</span> = High magnitude
              </div>
            )}

          <div className="mt-4 pb-3 border-t border-gray-300 pt-3">
            <h4 className="text-sm font-semibold mb-3 text-center">Add Trajectory (max 2)</h4>
            <div className="flex items-center justify-center gap-3 flex-wrap">
              <div className="flex items-center gap-2">
                <label className="text-sm font-medium">
                  {data.labels?.[data.selectedStates?.[0] || 0] || 'x'}:
                </label>
                <input
                  type="number"
                  step="0.1"
                  value={ic3DX}
                  onChange={(e) => setIc3DX(e.target.value)}
                  className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                  disabled={trajectories.length >= 2}
                />
              </div>
              <div className="flex items-center gap-2">
                <label className="text-sm font-medium">
                  {data.labels?.[data.selectedStates?.[1] || 1] || 'y'}:
                </label>
                <input
                  type="number"
                  step="0.1"
                  value={ic3DY}
                  onChange={(e) => setIc3DY(e.target.value)}
                  className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                  disabled={trajectories.length >= 2}
                />
              </div>
              <div className="flex items-center gap-2">
                <label className="text-sm font-medium">
                  {data.labels?.[data.selectedStates?.[2] || 2] || 'z'}:
                </label>
                <input
                  type="number"
                  step="0.1"
                  value={ic3DZ}
                  onChange={(e) => setIc3DZ(e.target.value)}
                  className="w-20 px-2 py-1 border border-gray-300 rounded text-sm"
                  disabled={trajectories.length >= 2}
                />
              </div>
              <button
                onClick={handleAdd3DTrajectory}
                className="px-4 py-1 bg-green-500 text-white rounded hover:bg-green-600 transition-colors text-sm font-semibold"
                disabled={trajectories.length >= 2}
              >
                Add Trajectory
              </button>
            </div>
            {bounds && bounds.min && bounds.max && (
              <div className="mt-2 text-xs text-gray-500 text-center">
                Bounds: {data.labels?.[data.selectedStates?.[0] || 0] || 'x'} ∈ [{bounds.min[data.selectedStates?.[0] || 0]?.toFixed(1) || '?'}, {bounds.max[data.selectedStates?.[0] || 0]?.toFixed(1) || '?'}],
                {' '}{data.labels?.[data.selectedStates?.[1] || 1] || 'y'} ∈ [{bounds.min[data.selectedStates?.[1] || 1]?.toFixed(1) || '?'}, {bounds.max[data.selectedStates?.[1] || 1]?.toFixed(1) || '?'}],
                {' '}{data.labels?.[data.selectedStates?.[2] || 2] || 'z'} ∈ [{bounds.min[data.selectedStates?.[2] || 2]?.toFixed(1) || '?'}, {bounds.max[data.selectedStates?.[2] || 2]?.toFixed(1) || '?'}]
              </div>
            )}
          </div>
          </>
        )}
      </div>
    </div>
  )
}

// Utility: Calculate bounds from system characteristics
function calculateBounds(data: VectorFieldData): { min: number[], max: number[] } {
  if (data.A) {
    // Linear system: estimate based on A matrix
    const n = data.A.length
    let maxVal = 0

    // Find max absolute value in A
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        maxVal = Math.max(maxVal, Math.abs(data.A[i][j]))
      }
    }

    const bound = Math.max(5, maxVal * 3)
    return {
      min: new Array(n).fill(-bound),
      max: new Array(n).fill(bound)
    }
  }

  // Default bounds for nonlinear or unknown systems
  const n = data.dimension === 3 ? 3 : 2
  return {
    min: new Array(n).fill(-10),
    max: new Array(n).fill(10)
  }
}
