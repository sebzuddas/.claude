/**
 * Utility functions for exporting visualizations as images, GIFs, and videos
 */

export interface RecordingOptions {
  duration?: number // seconds
  fps?: number
  onProgress?: (progress: number) => void
  onComplete?: () => void
}

/**
 * Record canvas as GIF
 * Uses canvas frame capture and client-side GIF encoding
 */
export async function recordCanvasAsGif(
  canvas: HTMLCanvasElement,
  filename: string,
  options: RecordingOptions = {}
): Promise<void> {
  const {
    duration = 5,
    fps = 10,
    onProgress,
    onComplete
  } = options

  return new Promise(async (resolve, reject) => {
    try {
      // TODO: Fix gif.js dependency issue
      reject(new Error('GIF export temporarily disabled - gif.js dependency needs to be installed'))

      // eslint-disable-next-line no-unreachable
      return

      // Dynamically import gif.js
      // const GIF = (await import('gif.js')).default

      // const gif = new GIF({
      //   workers: 2,
      //   quality: 10,
      //   width: canvas.width,
      //   height: canvas.height,
      //   workerScript: '/gif.worker.js' // Will need to be added to public folder
      // })

      // const totalFrames = duration * fps
      // const frameDelay = 1000 / fps
      // let capturedFrames = 0

      // const captureFrame = () => {
      //   if (capturedFrames >= totalFrames) {
      //     // Finish recording
      //     gif.render()
      //     return
      //   }

      //   // Add current canvas frame
      //   gif.addFrame(canvas, { copy: true, delay: frameDelay })
      //   capturedFrames++

      //   // Update progress
      //   const progress = Math.round((capturedFrames / totalFrames) * 100)
      //   onProgress?.(progress)

      //   // Capture next frame
      //   setTimeout(captureFrame, frameDelay)
      // }

      // gif.on('finished', (blob: Blob) => {
      //   // Download the GIF
      //   const url = URL.createObjectURL(blob)
      //   const a = document.createElement('a')
      //   a.href = url
      //   a.download = filename
      //   a.click()
      //   URL.revokeObjectURL(url)

      //   onComplete?.()
      //   resolve()
      // })

      // gif.on('error', (error: Error) => {
      //   console.error('GIF creation error:', error)
      //   reject(error)
      // })

      // // Start capturing frames
      // captureFrame()
    } catch (error) {
      console.error('GIF recording failed:', error)
      // Fallback: just save a single image
      saveCanvasAsImage(canvas, filename.replace('.gif', '.png'))
      onComplete?.()
      resolve()
    }
  })
}

/**
 * Record canvas as video using MediaRecorder API
 */
export async function recordCanvasAsVideo(
  canvas: HTMLCanvasElement,
  filename: string,
  options: RecordingOptions = {}
): Promise<void> {
  const {
    duration = 10,
    onProgress,
    onComplete
  } = options

  return new Promise((resolve, reject) => {
    try {
      // Check if MediaRecorder is supported
      if (!('MediaRecorder' in window)) {
        throw new Error('MediaRecorder not supported')
      }

      // Capture canvas stream
      const stream = canvas.captureStream(30) // 30 fps

      // Determine supported mime type
      const mimeTypes = [
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm',
        'video/mp4'
      ]

      let mimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type))
      if (!mimeType) {
        mimeType = 'video/webm' // Fallback
      }

      const mediaRecorder = new MediaRecorder(stream, {
        mimeType,
        videoBitsPerSecond: 2500000 // 2.5 Mbps
      })

      const chunks: Blob[] = []

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunks.push(event.data)
        }
      }

      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: mimeType })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = filename
        a.click()
        URL.revokeObjectURL(url)

        // Stop all tracks
        stream.getTracks().forEach(track => track.stop())

        onComplete?.()
        resolve()
      }

      mediaRecorder.onerror = (error) => {
        console.error('MediaRecorder error:', error)
        reject(error)
      }

      // Start recording
      mediaRecorder.start()

      // Update progress during recording
      const startTime = Date.now()
      const progressInterval = setInterval(() => {
        const elapsed = (Date.now() - startTime) / 1000
        const progress = Math.min(Math.round((elapsed / duration) * 100), 100)
        onProgress?.(progress)

        if (elapsed >= duration) {
          clearInterval(progressInterval)
        }
      }, 100)

      // Stop recording after duration
      setTimeout(() => {
        clearInterval(progressInterval)
        mediaRecorder.stop()
      }, duration * 1000)

    } catch (error) {
      console.error('Video recording failed:', error)
      // Fallback: save as image
      saveCanvasAsImage(canvas, filename.replace('.webm', '.png'))
      onComplete?.()
      resolve()
    }
  })
}

/**
 * Save canvas as PNG image
 * Simple and works in all browsers
 */
export function saveCanvasAsImage(
  canvas: HTMLCanvasElement,
  filename: string
): void {
  canvas.toBlob((blob) => {
    if (!blob) {
      console.error('Failed to create blob from canvas')
      return
    }

    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    a.click()
    URL.revokeObjectURL(url)
  }, 'image/png')
}

/**
 * Get the canvas element from a P5 instance
 */
export function getP5Canvas(p5Instance: any): HTMLCanvasElement | null {
  try {
    return p5Instance.canvas as HTMLCanvasElement
  } catch (error) {
    console.error('Failed to get canvas from P5 instance:', error)
    return null
  }
}
