/**
 * ABM Simulation Controller
 *
 * Manages the simulation lifecycle:
 * - Model initialization from JSON
 * - Tick execution with process scheduling
 * - Rule evaluation
 * - State management
 * - Data collection
 */

import type {
  ABMModelDefinition,
  Entity,
  EntityId,
  Vector2D,
  RuleDefinition,
  ProcessScheduleEntry,
  SimulationEvent,
  ArchetypeDefinition,
  EntitySpawnConfig,
  SteeringBehaviorComponent,
  ConditionExpression,
  ObservationConfig,
  EnvironmentConfig,
  ZoneDefinition
} from '../types'
import { World, Entity as EntityClass, SpatialHashGrid, Grid2DSpatialIndex, createSeededRNG, generateSeed, deepClone } from './ecs'
import { evaluateCondition, evaluateEffect, evaluateValue, EvaluationContext, EffectResult } from './evaluator'
import { VectorMath, MathPrimitives, SteeringPrimitives, SpatialPrimitives } from './primitives'

// =============================================================================
// SIMULATION STATE
// =============================================================================

export interface SimulationState {
  tick: number
  time: number
  paused: boolean
  speed: number
  seed: number
  initialized: boolean
}

export interface TimeseriesData {
  name: string
  values: number[]
  ticks: number[]
}

export interface SimulationSnapshot {
  tick: number
  entities: Array<{ id: EntityId; archetype: string; components: Record<string, unknown> }>
}

// =============================================================================
// EVENT EMITTER
// =============================================================================

type EventCallback = (...args: unknown[]) => void

class EventEmitter {
  private listeners: Map<string, Set<EventCallback>> = new Map()

  on(event: string, callback: EventCallback): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set())
    }
    this.listeners.get(event)!.add(callback)
  }

  off(event: string, callback: EventCallback): void {
    this.listeners.get(event)?.delete(callback)
  }

  emit(event: string, ...args: unknown[]): void {
    this.listeners.get(event)?.forEach(callback => callback(...args))
  }
}

// =============================================================================
// SIMULATION CONTROLLER
// =============================================================================

export class SimulationController extends EventEmitter {
  private model: ABMModelDefinition | null = null
  private world: World | null = null
  private state: SimulationState
  private rng: () => number
  private rules: RuleDefinition[] = []
  private processSchedule: ProcessScheduleEntry[] = []
  private timeseries: Map<string, TimeseriesData> = new Map()
  private eventLog: SimulationEvent[] = []
  private snapshots: SimulationSnapshot[] = []
  private parameters: Record<string, unknown> = {}
  private zones: ZoneDefinition[] = []
  private environmentConfig: EnvironmentConfig | null = null
  private initialState: { entities: Array<{ id: EntityId; archetype: string; components: Record<string, unknown> }> } | null = null

  constructor() {
    super()
    this.state = {
      tick: 0,
      time: 0,
      paused: true,
      speed: 1,
      seed: generateSeed(),
      initialized: false
    }
    this.rng = createSeededRNG(this.state.seed)
  }

  // ===========================================================================
  // INITIALIZATION
  // ===========================================================================

  /**
   * Initialize simulation from model definition
   */
  initialize(model: ABMModelDefinition): void {
    this.model = model
    this.state.initialized = false

    // Set seed
    if (model.designConcepts.stochasticity?.seed !== undefined) {
      this.state.seed = model.designConcepts.stochasticity.seed
    } else {
      this.state.seed = generateSeed()
    }
    this.rng = createSeededRNG(this.state.seed)

    // Create world with appropriate spatial index
    this.environmentConfig = model.overview.scales.spatial
    const spatialConfig = model.overview.scales.spatial.spatial
    const boundary = model.overview.scales.spatial.boundary

    let spatialIndex
    if (spatialConfig.type === 'grid2D') {
      spatialIndex = new Grid2DSpatialIndex(
        spatialConfig.width,
        spatialConfig.height,
        spatialConfig.cellSize || 1,
        boundary
      )
    } else {
      spatialIndex = new SpatialHashGrid(
        spatialConfig.width,
        spatialConfig.height,
        spatialConfig.cellSize || 50,
        boundary
      )
    }

    this.world = new World(spatialIndex)

    // Register archetypes
    for (const archetype of model.overview.entities.archetypes) {
      this.world.registerArchetype(archetype)
    }

    // Store zones
    this.zones = model.overview.scales.spatial.features?.zones || []

    // Store rules
    this.rules = model.designConcepts.interaction?.rules || []

    // Store process schedule
    this.processSchedule = model.overview.processSchedule

    // Initialize observation timeseries
    if (model.designConcepts.observation?.timeseries) {
      for (const ts of model.designConcepts.observation.timeseries) {
        this.timeseries.set(ts.name, { name: ts.name, values: [], ticks: [] })
      }
    }

    // Spawn initial entities
    this.spawnInitialEntities(model.details.initialization.entities)

    // Flush world to finalize entity creation
    this.world.flush()

    // Store initial state for reset
    this.initialState = this.world.serialize()

    // Reset simulation state
    this.state.tick = 0
    this.state.time = 0
    this.state.paused = true
    this.state.initialized = true

    this.emit('initialized', this.getState())
  }

  /**
   * Spawn entities based on spawn configuration
   */
  private spawnInitialEntities(configs: EntitySpawnConfig[]): void {
    if (!this.world || !this.environmentConfig) return

    const spatialConfig = this.environmentConfig.spatial

    for (const config of configs) {
      const count = config.count || 1

      for (let i = 0; i < count; i++) {
        // Create entity from archetype
        const entity = this.world.createEntity(config.archetype)

        // Set position
        if (config.position) {
          const position = this.generatePosition(config.position, i, count, spatialConfig)
          entity.setComponent('Position', position)
        } else {
          // Random position if not specified
          entity.setComponent('Position', {
            x: this.rng() * spatialConfig.width,
            y: this.rng() * spatialConfig.height
          })
        }

        // Apply property variations
        if (config.propertyVariation) {
          for (const [path, variation] of Object.entries(config.propertyVariation)) {
            let value: unknown

            switch (variation.distribution) {
              case 'uniform':
                value = MathPrimitives.sampleUniform(
                  variation.min || 0,
                  variation.max || 1,
                  this.rng
                )
                break
              case 'normal':
                value = MathPrimitives.sampleNormal(
                  variation.mean || 0,
                  variation.stdDev || 1,
                  this.rng
                )
                break
              case 'fixed':
              default:
                value = variation.value
            }

            entity.setProperty(path, value)
          }
        }

        this.world.addEntity(entity)
      }
    }
  }

  /**
   * Generate position based on position config
   */
  private generatePosition(
    posConfig: NonNullable<EntitySpawnConfig['position']>,
    index: number,
    total: number,
    spatialConfig: { width: number; height: number; cellSize?: number }
  ): Vector2D {
    switch (posConfig.type) {
      case 'fixed':
        if (Array.isArray(posConfig.value)) {
          return posConfig.value[index % posConfig.value.length]
        }
        return posConfig.value || { x: 0, y: 0 }

      case 'random':
        const region = posConfig.region || {
          min: { x: 0, y: 0 },
          max: { x: spatialConfig.width, y: spatialConfig.height }
        }
        return {
          x: MathPrimitives.sampleUniform(region.min.x, region.max.x, this.rng),
          y: MathPrimitives.sampleUniform(region.min.y, region.max.y, this.rng)
        }

      case 'grid':
        const cols = Math.ceil(Math.sqrt(total))
        const spacing = posConfig.spacing || spatialConfig.cellSize || 10
        const col = index % cols
        const row = Math.floor(index / cols)
        return {
          x: col * spacing + spacing / 2,
          y: row * spacing + spacing / 2
        }

      case 'cluster':
        const center = posConfig.value as Vector2D || {
          x: spatialConfig.width / 2,
          y: spatialConfig.height / 2
        }
        const radius = posConfig.spacing || 50
        const angle = this.rng() * Math.PI * 2
        const r = this.rng() * radius
        return {
          x: center.x + Math.cos(angle) * r,
          y: center.y + Math.sin(angle) * r
        }

      default:
        return { x: this.rng() * spatialConfig.width, y: this.rng() * spatialConfig.height }
    }
  }

  // ===========================================================================
  // SIMULATION CONTROL
  // ===========================================================================

  play(): void {
    if (!this.state.initialized) return
    this.state.paused = false
    this.emit('stateChanged', this.getState())
  }

  pause(): void {
    this.state.paused = true
    this.emit('stateChanged', this.getState())
  }

  reset(): void {
    if (!this.world || !this.initialState) return

    // Restore initial state
    this.world.deserialize(this.initialState as Parameters<typeof this.world.deserialize>[0])

    // Reset simulation state
    this.state.tick = 0
    this.state.time = 0
    this.state.paused = true

    // Reset RNG with same seed
    this.rng = createSeededRNG(this.state.seed)

    // Clear collected data
    this.timeseries.forEach(ts => {
      ts.values = []
      ts.ticks = []
    })
    this.eventLog = []
    this.snapshots = []

    this.emit('reset')
    this.emit('stateChanged', this.getState())
  }

  setSpeed(speed: number): void {
    this.state.speed = MathPrimitives.clamp(speed, 0.1, 10)
    this.emit('stateChanged', this.getState())
  }

  setSeed(seed: number): void {
    this.state.seed = seed
    this.rng = createSeededRNG(seed)
    this.emit('stateChanged', this.getState())
  }

  setParameter(path: string, value: unknown): void {
    const parts = path.split('.')
    let current = this.parameters as Record<string, unknown>

    for (let i = 0; i < parts.length - 1; i++) {
      if (current[parts[i]] === undefined) {
        current[parts[i]] = {}
      }
      current = current[parts[i]] as Record<string, unknown>
    }

    current[parts[parts.length - 1]] = value
    this.emit('parameterChanged', path, value)
  }

  // ===========================================================================
  // TICK EXECUTION
  // ===========================================================================

  /**
   * Execute one simulation tick
   */
  step(): void {
    if (!this.world || !this.model || !this.state.initialized) return

    const dt = this.model.overview.scales.temporal.dt

    // Execute process schedule
    for (const process of this.processSchedule) {
      this.executeProcess(process, dt)
    }

    // Collect observations
    this.collectObservations()

    // Take snapshot if configured
    const snapshotConfig = this.model.designConcepts.observation?.snapshots
    if (snapshotConfig && this.state.tick % snapshotConfig.every === 0) {
      this.takeSnapshot(snapshotConfig.include)
    }

    // Flush world (process pending additions/removals)
    this.world.flush()

    // Increment tick and time
    this.state.tick++
    this.state.time += dt

    this.emit('tick', this.state.tick)
    this.emit('stateChanged', this.getState())

    // Check termination conditions
    const maxTicks = this.model.overview.scales.temporal.maxTicks
    const maxTime = this.model.overview.scales.temporal.maxTime

    if ((maxTicks && this.state.tick >= maxTicks) || (maxTime && this.state.time >= maxTime)) {
      this.pause()
      this.emit('completed')
    }
  }

  /**
   * Execute a scheduled process
   */
  private executeProcess(process: ProcessScheduleEntry, dt: number): void {
    if (!this.world) return

    const entities = this.world.getAllEntities()

    // Determine execution order
    let orderedEntities = [...entities]
    if (process.shuffle) {
      // Fisher-Yates shuffle
      for (let i = orderedEntities.length - 1; i > 0; i--) {
        const j = Math.floor(this.rng() * (i + 1));
        [orderedEntities[i], orderedEntities[j]] = [orderedEntities[j], orderedEntities[i]]
      }
    }

    // Execute based on system type
    switch (process.system) {
      case 'Movement':
        this.executeMovementSystem(orderedEntities, dt, process.order === 'parallel')
        break

      case 'Steering':
        this.executeSteeringSystem(orderedEntities, dt, process.order === 'parallel')
        break

      case 'Rules':
      case 'Interaction':
        this.executeRulesSystem(orderedEntities, dt, process.order === 'parallel')
        break

      case 'GridUpdate':
        this.executeGridUpdateSystem(orderedEntities, dt)
        break

      default:
        // Unknown system, try to find matching rules
        const matchingRules = this.rules.filter(r => r.name.startsWith(process.system))
        if (matchingRules.length > 0) {
          this.executeSpecificRules(orderedEntities, matchingRules, dt, process.order === 'parallel')
        }
    }
  }

  /**
   * Execute movement system - updates positions based on velocity
   */
  private executeMovementSystem(entities: Entity[], dt: number, parallel: boolean): void {
    if (!this.world || !this.environmentConfig) return

    const updates: Array<{ entity: EntityClass; newPos: Vector2D }> = []

    for (const entity of entities) {
      const entityObj = entity as EntityClass
      const position = entityObj.getComponent<Vector2D>('Position')
      const velocity = entityObj.getComponent<Vector2D>('Velocity')

      if (position && velocity) {
        let newPos = VectorMath.add(position, VectorMath.mul(velocity, dt))

        // Apply boundary conditions
        const width = this.environmentConfig.spatial.width
        const height = this.environmentConfig.spatial.height

        if (this.environmentConfig.boundary === 'toroidal') {
          newPos.x = ((newPos.x % width) + width) % width
          newPos.y = ((newPos.y % height) + height) % height
        } else if (this.environmentConfig.boundary === 'bounded') {
          // Reflect velocity when hitting boundaries
          let newVel = { ...velocity }
          if (newPos.x <= 0 || newPos.x >= width) {
            newVel.x = -velocity.x * 0.8  // Reverse and dampen
          }
          if (newPos.y <= 0 || newPos.y >= height) {
            newVel.y = -velocity.y * 0.8  // Reverse and dampen
          }
          // Update velocity if changed
          if (newVel.x !== velocity.x || newVel.y !== velocity.y) {
            entityObj.setComponent('Velocity', newVel)
          }
          // Clamp position
          newPos.x = MathPrimitives.clamp(newPos.x, 0, width)
          newPos.y = MathPrimitives.clamp(newPos.y, 0, height)
        }

        if (parallel) {
          updates.push({ entity: entityObj, newPos })
        } else {
          entityObj.setComponent('Position', newPos)
          this.world.updateEntityPosition(entityObj.id, newPos)
        }
      }
    }

    // Apply parallel updates
    if (parallel && this.world) {
      for (const { entity, newPos } of updates) {
        entity.setComponent('Position', newPos)
        this.world.updateEntityPosition(entity.id, newPos)
      }
    }
  }

  /**
   * Execute steering system - calculates steering forces and updates velocity
   */
  private executeSteeringSystem(entities: Entity[], dt: number, parallel: boolean): void {
    if (!this.world) return

    const updates: Array<{ entity: EntityClass; newVel: Vector2D }> = []

    for (const entity of entities) {
      const entityObj = entity as EntityClass
      const steering = entityObj.getComponent<SteeringBehaviorComponent>('SteeringBehavior')
      const velocity = entityObj.getComponent<Vector2D>('Velocity')

      if (steering && steering.rules && velocity) {
        const maxSpeed = steering.maxSpeed || 100
        const maxForce = steering.maxForce || 10

        const force = SteeringPrimitives.calculateCombinedSteering(
          entityObj,
          this.world,
          steering.rules,
          maxSpeed,
          maxForce,
          this.rng,
          (condition, e, other) => this.evaluateConditionForEntity(condition, e as EntityClass, other as EntityClass | undefined)
        )

        // Apply force to velocity
        let newVel = VectorMath.add(velocity, VectorMath.mul(force, dt))
        newVel = VectorMath.limit(newVel, maxSpeed)

        if (parallel) {
          updates.push({ entity: entityObj, newVel })
        } else {
          entityObj.setComponent('Velocity', newVel)
        }
      }
    }

    // Apply parallel updates
    for (const { entity, newVel } of updates) {
      entity.setComponent('Velocity', newVel)
    }
  }

  /**
   * Execute rules system - evaluates all interaction rules
   */
  private executeRulesSystem(entities: Entity[], dt: number, _parallel: boolean): void {
    this.executeSpecificRules(entities, this.rules, dt, _parallel)
  }

  /**
   * Execute specific rules
   */
  private executeSpecificRules(entities: Entity[], rules: RuleDefinition[], dt: number, _parallel: boolean): void {
    if (!this.world) return

    const allEffects: EffectResult[] = []

    for (const rule of rules) {
      // Filter entities that this rule applies to
      let applicableEntities = entities
      if (rule.appliesTo) {
        applicableEntities = entities.filter(e =>
          this.evaluateConditionForEntity(rule.appliesTo!, e as EntityClass)
        )
      }

      // Check trigger type
      if ('everyTick' in rule.trigger) {
        for (const entity of applicableEntities) {
          const effects = this.evaluateRuleForEntity(rule, entity as EntityClass, dt)
          if (effects) allEffects.push(effects)
        }
      } else if ('onProximity' in rule.trigger) {
        const proximityTrigger = rule.trigger.onProximity
        const radius = proximityTrigger.radius
        for (const entity of applicableEntities) {
          const entityObj = entity as EntityClass
          const position = entityObj.getComponent<Vector2D>('Position')
          if (!position) continue

          const neighbors = SpatialPrimitives.withinRadius(
            this.world,
            position,
            radius,
            e => e.id !== entityObj.id
          )

          // Apply filter if specified
          let filtered = neighbors
          if (proximityTrigger.filter) {
            filtered = neighbors.filter(n =>
              this.evaluateConditionForEntity(proximityTrigger.filter!, entityObj, n as EntityClass)
            )
          }

          for (const other of filtered) {
            const effects = this.evaluateRuleForEntity(rule, entityObj, dt, other as EntityClass)
            if (effects) allEffects.push(effects)
          }
        }
      }
    }

    // Apply all effects
    this.applyEffects(allEffects)
  }

  /**
   * Execute grid update system (for cellular automata)
   */
  private executeGridUpdateSystem(entities: Entity[], dt: number): void {
    // For grid-based simulations, calculate next state based on neighbors
    // This is specialized for Game of Life style simulations
    if (!this.world) return

    const spatialIndex = this.world.getSpatialIndex()
    if (spatialIndex.type !== 'grid2D') return

    const gridIndex = spatialIndex as Grid2DSpatialIndex
    const updates: Array<{ entity: EntityClass; nextState: { alive: boolean } }> = []

    for (const entity of entities) {
      const entityObj = entity as EntityClass
      const position = entityObj.getComponent<Vector2D>('Position')
      const cellState = entityObj.getComponent<{ alive?: boolean; state?: string }>('CellState')

      if (position && cellState) {
        const cellX = Math.floor(position.x)
        const cellY = Math.floor(position.y)
        const neighborIds = gridIndex.getNeighbors(cellX, cellY)
        const neighbors = neighborIds.map(id => this.world!.getEntity(id)).filter((e): e is EntityClass => e !== undefined)

        // Count alive neighbors
        const aliveNeighbors = neighbors.filter(n => {
          const state = n.getComponent<{ alive?: boolean }>('CellState')
          return state?.alive
        }).length

        // Game of Life rules
        const isAlive = cellState.alive
        let nextAlive = isAlive

        if (isAlive) {
          // Alive cell: dies if < 2 or > 3 neighbors
          nextAlive = aliveNeighbors === 2 || aliveNeighbors === 3
        } else {
          // Dead cell: becomes alive if exactly 3 neighbors
          nextAlive = aliveNeighbors === 3
        }

        updates.push({
          entity: entityObj,
          nextState: { alive: nextAlive }
        })
      }
    }

    // Apply updates (parallel)
    for (const { entity, nextState } of updates) {
      entity.setComponent('CellState', nextState)
    }
  }

  /**
   * Evaluate a rule for a specific entity
   */
  private evaluateRuleForEntity(rule: RuleDefinition, entity: EntityClass, dt: number, other?: EntityClass): EffectResult | null {
    if (!this.world) return null

    const ctx: EvaluationContext = {
      world: this.world,
      self: entity,
      other,
      tick: this.state.tick,
      dt,
      rng: this.rng,
      zones: this.zones,
      parameters: this.parameters
    }

    // Check condition
    if (rule.condition) {
      const conditionMet = evaluateCondition(rule.condition, ctx)
      if (!conditionMet) return null
    }

    // Evaluate effect
    return evaluateEffect(rule.effect, ctx)
  }

  /**
   * Evaluate a condition for a specific entity
   */
  private evaluateConditionForEntity(condition: ConditionExpression, entity: EntityClass, other?: EntityClass): boolean {
    if (!this.world) return false

    const ctx: EvaluationContext = {
      world: this.world,
      self: entity,
      other,
      tick: this.state.tick,
      dt: this.model?.overview.scales.temporal.dt || 0.1,
      rng: this.rng,
      zones: this.zones,
      parameters: this.parameters
    }

    return evaluateCondition(condition, ctx)
  }

  /**
   * Apply effect results to the world
   */
  private applyEffects(effects: EffectResult[]): void {
    if (!this.world) return

    for (const effect of effects) {
      // Apply property changes
      for (const change of effect.propertyChanges) {
        const entity = this.world.getEntity(change.entityId)
        if (entity) {
          (entity as EntityClass).setProperty(change.path, change.value)

          // Update spatial index if position changed
          if (change.path === 'Position' || change.path.startsWith('Position.')) {
            const position = (entity as EntityClass).getComponent<Vector2D>('Position')
            if (position) {
              this.world.updateEntityPosition(entity.id, position)
            }
          }
        }
      }

      // Process spawns
      for (const spawn of effect.spawns) {
        const newEntity = this.world.createEntity(spawn.archetype)

        if (spawn.position) {
          newEntity.setComponent('Position', spawn.position)
        }

        if (spawn.properties) {
          for (const [path, value] of Object.entries(spawn.properties)) {
            newEntity.setProperty(path, value)
          }
        }

        this.world.addEntity(newEntity)
      }

      // Process destroys
      for (const entityId of effect.destroys) {
        this.world.removeEntity(entityId)
      }

      // Log events
      for (const event of effect.events) {
        this.eventLog.push(event)
        this.emit('simulationEvent', event)
      }
    }
  }

  // ===========================================================================
  // OBSERVATION & DATA COLLECTION
  // ===========================================================================

  private collectObservations(): void {
    if (!this.world || !this.model?.designConcepts.observation?.timeseries) return

    for (const obs of this.model.designConcepts.observation.timeseries) {
      const ts = this.timeseries.get(obs.name)
      if (!ts) continue

      // Create a dummy entity for evaluation context (for global aggregations)
      const dummyEntity = new EntityClass('_observer', '_observer')

      const ctx: EvaluationContext = {
        world: this.world,
        self: dummyEntity,
        tick: this.state.tick,
        dt: this.model.overview.scales.temporal.dt,
        rng: this.rng,
        zones: this.zones,
        parameters: this.parameters
      }

      const value = evaluateValue(obs.query, ctx)
      if (typeof value === 'number') {
        ts.values.push(value)
        ts.ticks.push(this.state.tick)
      }
    }
  }

  private takeSnapshot(includeComponents: string[]): void {
    if (!this.world) return

    const entities = this.world.getAllEntities().map(entity => {
      const entityObj = entity as EntityClass
      const components: Record<string, unknown> = {}

      for (const componentType of includeComponents) {
        const component = entityObj.getComponent(componentType)
        if (component) {
          components[componentType] = deepClone(component)
        }
      }

      return {
        id: entityObj.id,
        archetype: entityObj.archetype,
        components
      }
    })

    this.snapshots.push({
      tick: this.state.tick,
      entities
    })
  }

  // ===========================================================================
  // STATE ACCESSORS
  // ===========================================================================

  getState(): SimulationState {
    return { ...this.state }
  }

  getEntities(): Entity[] {
    return this.world?.getAllEntities() || []
  }

  getEntity(id: EntityId): Entity | undefined {
    return this.world?.getEntity(id)
  }

  getTimeseries(): Map<string, TimeseriesData> {
    return new Map(this.timeseries)
  }

  getEventLog(): SimulationEvent[] {
    return [...this.eventLog]
  }

  getSnapshots(): SimulationSnapshot[] {
    return [...this.snapshots]
  }

  getModel(): ABMModelDefinition | null {
    return this.model
  }

  getEnvironmentConfig(): EnvironmentConfig | null {
    return this.environmentConfig
  }

  getSeed(): number {
    return this.state.seed
  }

  // ===========================================================================
  // EXPORT
  // ===========================================================================

  exportJSON(): string {
    return JSON.stringify({
      model: this.model,
      state: this.state,
      timeseries: Object.fromEntries(this.timeseries),
      eventLog: this.eventLog,
      snapshots: this.snapshots
    }, null, 2)
  }

  exportCSV(): string {
    const lines: string[] = []

    // Header
    const tsNames = Array.from(this.timeseries.keys())
    lines.push(['tick', ...tsNames].join(','))

    // Find max length
    const maxLength = Math.max(...Array.from(this.timeseries.values()).map(ts => ts.values.length))

    // Data rows
    for (let i = 0; i < maxLength; i++) {
      const row = [i.toString()]
      for (const name of tsNames) {
        const ts = this.timeseries.get(name)
        row.push(ts && i < ts.values.length ? ts.values[i].toString() : '')
      }
      lines.push(row.join(','))
    }

    return lines.join('\n')
  }
}
