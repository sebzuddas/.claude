/**
 * ABM Primitives Library
 *
 * Domain-agnostic operations that behaviors compose from:
 * - Spatial: withinRadius, nearestN, inRegion, distance
 * - Aggregation: average, sum, count, min, max
 * - Steering: seek, flee, arrive, wander, separation, alignment, cohesion
 * - Filters: component presence, property comparisons
 * - State: transition, timer, counter, set, increment
 * - Math: lerp, clamp, noise, sampleDistribution, arithmetic
 */

import type { Vector2D, Entity, SteeringRule, ConditionExpression } from '../types'
import { World } from './ecs'

// =============================================================================
// VECTOR MATH PRIMITIVES
// =============================================================================

export const VectorMath = {
  add(a: Vector2D, b: Vector2D): Vector2D {
    return { x: a.x + b.x, y: a.y + b.y }
  },

  sub(a: Vector2D, b: Vector2D): Vector2D {
    return { x: a.x - b.x, y: a.y - b.y }
  },

  mul(v: Vector2D, scalar: number): Vector2D {
    return { x: v.x * scalar, y: v.y * scalar }
  },

  div(v: Vector2D, scalar: number): Vector2D {
    if (scalar === 0) return { x: 0, y: 0 }
    return { x: v.x / scalar, y: v.y / scalar }
  },

  magnitude(v: Vector2D): number {
    return Math.sqrt(v.x * v.x + v.y * v.y)
  },

  magnitudeSquared(v: Vector2D): number {
    return v.x * v.x + v.y * v.y
  },

  normalize(v: Vector2D): Vector2D {
    const mag = this.magnitude(v)
    if (mag === 0) return { x: 0, y: 0 }
    return this.div(v, mag)
  },

  limit(v: Vector2D, max: number): Vector2D {
    const magSq = this.magnitudeSquared(v)
    if (magSq > max * max) {
      return this.mul(this.normalize(v), max)
    }
    return v
  },

  setMagnitude(v: Vector2D, mag: number): Vector2D {
    return this.mul(this.normalize(v), mag)
  },

  distance(a: Vector2D, b: Vector2D): number {
    return this.magnitude(this.sub(b, a))
  },

  distanceSquared(a: Vector2D, b: Vector2D): number {
    return this.magnitudeSquared(this.sub(b, a))
  },

  dot(a: Vector2D, b: Vector2D): number {
    return a.x * b.x + a.y * b.y
  },

  angle(v: Vector2D): number {
    return Math.atan2(v.y, v.x)
  },

  fromAngle(angle: number, magnitude: number = 1): Vector2D {
    return { x: Math.cos(angle) * magnitude, y: Math.sin(angle) * magnitude }
  },

  rotate(v: Vector2D, angle: number): Vector2D {
    const cos = Math.cos(angle)
    const sin = Math.sin(angle)
    return {
      x: v.x * cos - v.y * sin,
      y: v.x * sin + v.y * cos
    }
  },

  lerp(a: Vector2D, b: Vector2D, t: number): Vector2D {
    return {
      x: a.x + (b.x - a.x) * t,
      y: a.y + (b.y - a.y) * t
    }
  },

  zero(): Vector2D {
    return { x: 0, y: 0 }
  },

  random(rng: () => number): Vector2D {
    const angle = rng() * Math.PI * 2
    return { x: Math.cos(angle), y: Math.sin(angle) }
  }
}

// =============================================================================
// MATH PRIMITIVES
// =============================================================================

export const MathPrimitives = {
  lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t
  },

  clamp(value: number, min: number, max: number): number {
    return Math.max(min, Math.min(max, value))
  },

  map(value: number, fromMin: number, fromMax: number, toMin: number, toMax: number): number {
    return toMin + ((value - fromMin) / (fromMax - fromMin)) * (toMax - toMin)
  },

  // Simple 2D Perlin-like noise (simplified implementation)
  noise(x: number, y: number = 0, seed: number = 0): number {
    // Simple hash-based noise
    const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453
    return n - Math.floor(n)
  },

  // Sample from distributions
  sampleUniform(min: number, max: number, rng: () => number): number {
    return min + rng() * (max - min)
  },

  sampleNormal(mean: number, stdDev: number, rng: () => number): number {
    // Box-Muller transform
    const u1 = rng()
    const u2 = rng()
    const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2)
    return mean + z0 * stdDev
  },

  // Check if point is in rectangle
  inRectangle(point: Vector2D, min: Vector2D, max: Vector2D): boolean {
    return point.x >= min.x && point.x <= max.x && point.y >= min.y && point.y <= max.y
  },

  // Check if point is in circle
  inCircle(point: Vector2D, center: Vector2D, radius: number): boolean {
    return VectorMath.distanceSquared(point, center) <= radius * radius
  }
}

// =============================================================================
// SPATIAL PRIMITIVES
// =============================================================================

export const SpatialPrimitives = {
  /** Get entities within radius */
  withinRadius(
    world: World,
    center: Vector2D,
    radius: number,
    filter?: (entity: Entity) => boolean
  ): Entity[] {
    let entities = world.queryRadius(center, radius)
    if (filter) {
      entities = entities.filter(filter)
    }
    return entities
  },

  /** Get N nearest entities */
  nearestN(
    world: World,
    center: Vector2D,
    n: number,
    maxRadius: number = Infinity,
    filter?: (entity: Entity) => boolean
  ): Entity[] {
    let entities = world.queryRadius(center, maxRadius)
    if (filter) {
      entities = entities.filter(filter)
    }

    // Sort by distance and take first N
    return entities
      .map(entity => {
        const pos = entity.getComponent<Vector2D>('Position')
        return { entity, dist: pos ? VectorMath.distance(center, pos) : Infinity }
      })
      .sort((a, b) => a.dist - b.dist)
      .slice(0, n)
      .map(item => item.entity)
  },

  /** Check if entity is in a named zone */
  inZone(
    position: Vector2D,
    zones: Array<{ id: string; shape: 'rectangle' | 'circle'; position: Vector2D; size: Vector2D | number }>
  ): string[] {
    const result: string[] = []
    for (const zone of zones) {
      if (zone.shape === 'rectangle') {
        const size = zone.size as Vector2D
        const min = { x: zone.position.x - size.x / 2, y: zone.position.y - size.y / 2 }
        const max = { x: zone.position.x + size.x / 2, y: zone.position.y + size.y / 2 }
        if (MathPrimitives.inRectangle(position, min, max)) {
          result.push(zone.id)
        }
      } else if (zone.shape === 'circle') {
        const radius = zone.size as number
        if (MathPrimitives.inCircle(position, zone.position, radius)) {
          result.push(zone.id)
        }
      }
    }
    return result
  },

  /** Calculate distance between two entities */
  distance(entityA: Entity, entityB: Entity): number {
    const posA = entityA.getComponent<Vector2D>('Position')
    const posB = entityB.getComponent<Vector2D>('Position')
    if (!posA || !posB) return Infinity
    return VectorMath.distance(posA, posB)
  }
}

// =============================================================================
// AGGREGATION PRIMITIVES
// =============================================================================

export const AggregationPrimitives = {
  /** Count entities matching a filter */
  count(entities: Entity[], filter?: (entity: Entity) => boolean): number {
    if (!filter) return entities.length
    return entities.filter(filter).length
  },

  /** Sum a numeric property across entities */
  sum(entities: Entity[], propertyPath: string): number {
    return entities.reduce((acc, entity) => {
      const value = entity.getProperty(propertyPath)
      return acc + (typeof value === 'number' ? value : 0)
    }, 0)
  },

  /** Average a numeric property across entities */
  average(entities: Entity[], propertyPath: string): number {
    if (entities.length === 0) return 0
    return this.sum(entities, propertyPath) / entities.length
  },

  /** Find minimum value of a property */
  min(entities: Entity[], propertyPath: string): number {
    if (entities.length === 0) return Infinity
    return Math.min(...entities.map(e => {
      const value = e.getProperty(propertyPath)
      return typeof value === 'number' ? value : Infinity
    }))
  },

  /** Find maximum value of a property */
  max(entities: Entity[], propertyPath: string): number {
    if (entities.length === 0) return -Infinity
    return Math.max(...entities.map(e => {
      const value = e.getProperty(propertyPath)
      return typeof value === 'number' ? value : -Infinity
    }))
  },

  /** Calculate center of mass */
  centerOfMass(entities: Entity[]): Vector2D {
    if (entities.length === 0) return { x: 0, y: 0 }

    let totalX = 0
    let totalY = 0
    let count = 0

    for (const entity of entities) {
      const pos = entity.getComponent<Vector2D>('Position')
      if (pos) {
        totalX += pos.x
        totalY += pos.y
        count++
      }
    }

    if (count === 0) return { x: 0, y: 0 }
    return { x: totalX / count, y: totalY / count }
  },

  /** Calculate average velocity */
  averageVelocity(entities: Entity[]): Vector2D {
    if (entities.length === 0) return { x: 0, y: 0 }

    let totalX = 0
    let totalY = 0
    let count = 0

    for (const entity of entities) {
      const vel = entity.getComponent<Vector2D>('Velocity')
      if (vel) {
        totalX += vel.x
        totalY += vel.y
        count++
      }
    }

    if (count === 0) return { x: 0, y: 0 }
    return { x: totalX / count, y: totalY / count }
  }
}

// =============================================================================
// STEERING PRIMITIVES
// =============================================================================

export const SteeringPrimitives = {
  /** Seek: Steer towards a target position */
  seek(
    currentPos: Vector2D,
    currentVel: Vector2D,
    target: Vector2D,
    maxSpeed: number,
    maxForce: number
  ): Vector2D {
    const desired = VectorMath.sub(target, currentPos)
    const desiredNormalized = VectorMath.setMagnitude(desired, maxSpeed)
    const steering = VectorMath.sub(desiredNormalized, currentVel)
    return VectorMath.limit(steering, maxForce)
  },

  /** Flee: Steer away from a target position */
  flee(
    currentPos: Vector2D,
    currentVel: Vector2D,
    target: Vector2D,
    maxSpeed: number,
    maxForce: number
  ): Vector2D {
    const desired = VectorMath.sub(currentPos, target)
    const desiredNormalized = VectorMath.setMagnitude(desired, maxSpeed)
    const steering = VectorMath.sub(desiredNormalized, currentVel)
    return VectorMath.limit(steering, maxForce)
  },

  /** Arrive: Seek with slowing down near target */
  arrive(
    currentPos: Vector2D,
    currentVel: Vector2D,
    target: Vector2D,
    maxSpeed: number,
    maxForce: number,
    slowingRadius: number
  ): Vector2D {
    const desired = VectorMath.sub(target, currentPos)
    const distance = VectorMath.magnitude(desired)

    let speed = maxSpeed
    if (distance < slowingRadius) {
      speed = MathPrimitives.map(distance, 0, slowingRadius, 0, maxSpeed)
    }

    const desiredNormalized = VectorMath.setMagnitude(desired, speed)
    const steering = VectorMath.sub(desiredNormalized, currentVel)
    return VectorMath.limit(steering, maxForce)
  },

  /** Wander: Random steering for exploration */
  wander(
    currentVel: Vector2D,
    wanderAngle: number,
    wanderRadius: number,
    wanderDistance: number,
    wanderJitter: number,
    maxForce: number,
    rng: () => number
  ): { force: Vector2D; newAngle: number } {
    // Add small random vector to wander target
    const newAngle = wanderAngle + (rng() - 0.5) * wanderJitter

    // Calculate wander circle center (in front of agent)
    const circleCenter = VectorMath.setMagnitude(currentVel, wanderDistance)

    // Calculate displacement force on wander circle
    const displacement = VectorMath.fromAngle(newAngle, wanderRadius)

    // Combine to get wander force
    const wanderForce = VectorMath.add(circleCenter, displacement)

    return {
      force: VectorMath.limit(wanderForce, maxForce),
      newAngle
    }
  },

  /** Separation: Steer away from nearby agents */
  separation(
    currentPos: Vector2D,
    neighbors: Entity[],
    desiredSeparation: number,
    maxForce: number
  ): Vector2D {
    let steering = VectorMath.zero()
    let count = 0

    for (const neighbor of neighbors) {
      const neighborPos = neighbor.getComponent<Vector2D>('Position')
      if (!neighborPos) continue

      const diff = VectorMath.sub(currentPos, neighborPos)
      const distance = VectorMath.magnitude(diff)

      if (distance > 0 && distance < desiredSeparation) {
        // Weight by inverse distance
        const repulsion = VectorMath.div(VectorMath.normalize(diff), distance)
        steering = VectorMath.add(steering, repulsion)
        count++
      }
    }

    if (count > 0) {
      steering = VectorMath.div(steering, count)
    }

    return VectorMath.limit(steering, maxForce)
  },

  /** Alignment: Steer towards average heading of neighbors */
  alignment(
    currentVel: Vector2D,
    neighbors: Entity[],
    maxSpeed: number,
    maxForce: number
  ): Vector2D {
    const avgVelocity = AggregationPrimitives.averageVelocity(neighbors)

    if (VectorMath.magnitudeSquared(avgVelocity) === 0) {
      return VectorMath.zero()
    }

    const desired = VectorMath.setMagnitude(avgVelocity, maxSpeed)
    const steering = VectorMath.sub(desired, currentVel)
    return VectorMath.limit(steering, maxForce)
  },

  /** Cohesion: Steer towards center of mass of neighbors */
  cohesion(
    currentPos: Vector2D,
    currentVel: Vector2D,
    neighbors: Entity[],
    maxSpeed: number,
    maxForce: number
  ): Vector2D {
    const centerOfMass = AggregationPrimitives.centerOfMass(neighbors)

    if (neighbors.length === 0) {
      return VectorMath.zero()
    }

    return this.seek(currentPos, currentVel, centerOfMass, maxSpeed, maxForce)
  },

  /** Calculate combined steering from multiple rules */
  calculateCombinedSteering(
    entity: Entity,
    world: World,
    rules: SteeringRule[],
    maxSpeed: number,
    maxForce: number,
    rng: () => number,
    evaluateCondition?: (condition: ConditionExpression, entity: Entity, other?: Entity) => boolean
  ): Vector2D {
    const position = entity.getComponent<Vector2D>('Position')
    const velocity = entity.getComponent<Vector2D>('Velocity') || { x: 0, y: 0 }

    if (!position) return VectorMath.zero()

    let totalForce = VectorMath.zero()

    for (const rule of rules) {
      let force = VectorMath.zero()

      // Get neighbors if needed
      const radius = rule.query?.radius || 50
      let neighbors = SpatialPrimitives.withinRadius(world, position, radius, (e) => e.id !== entity.id)

      // Apply filter if specified
      if (rule.query?.filter && evaluateCondition) {
        neighbors = neighbors.filter(neighbor =>
          evaluateCondition(rule.query!.filter!, entity, neighbor)
        )
      }

      switch (rule.type) {
        case 'separation':
          force = this.separation(position, neighbors, radius / 2, maxForce)
          break

        case 'alignment':
          force = this.alignment(velocity, neighbors, maxSpeed, maxForce)
          break

        case 'cohesion':
          force = this.cohesion(position, velocity, neighbors, maxSpeed, maxForce)
          break

        case 'seek':
          if (neighbors.length > 0) {
            const targetPos = neighbors[0].getComponent<Vector2D>('Position')
            if (targetPos) {
              force = this.seek(position, velocity, targetPos, maxSpeed, maxForce)
            }
          }
          break

        case 'flee':
          if (neighbors.length > 0) {
            // Flee from nearest threat
            const threatPos = neighbors[0].getComponent<Vector2D>('Position')
            if (threatPos) {
              force = this.flee(position, velocity, threatPos, maxSpeed, maxForce)
            }
          }
          break

        case 'arrive':
          if (neighbors.length > 0) {
            const targetPos = neighbors[0].getComponent<Vector2D>('Position')
            if (targetPos) {
              force = this.arrive(
                position,
                velocity,
                targetPos,
                maxSpeed,
                maxForce,
                rule.params?.slowingRadius || 50
              )
            }
          }
          break

        case 'wander':
          const wanderState = entity.getComponent<{ angle: number }>('WanderState') || { angle: 0 }
          const result = this.wander(
            velocity,
            wanderState.angle,
            rule.params?.wanderRadius || 25,
            rule.params?.wanderDistance || 50,
            rule.params?.wanderJitter || 0.3,
            maxForce,
            rng
          )
          force = result.force
          entity.setComponent('WanderState', { angle: result.newAngle })
          break
      }

      // Apply weight
      totalForce = VectorMath.add(totalForce, VectorMath.mul(force, rule.weight))
    }

    return VectorMath.limit(totalForce, maxForce)
  }
}

// =============================================================================
// STATE PRIMITIVES
// =============================================================================

export const StatePrimitives = {
  /** Transition a state property to a new value */
  transition(entity: Entity, propertyPath: string, newValue: string): void {
    entity.setProperty(propertyPath, newValue)
  },

  /** Increment a numeric property */
  increment(entity: Entity, propertyPath: string, amount: number): void {
    const current = entity.getProperty(propertyPath)
    const newValue = (typeof current === 'number' ? current : 0) + amount
    entity.setProperty(propertyPath, newValue)
  },

  /** Decrement a numeric property */
  decrement(entity: Entity, propertyPath: string, amount: number): void {
    this.increment(entity, propertyPath, -amount)
  },

  /** Set a property value */
  set(entity: Entity, propertyPath: string, value: unknown): void {
    entity.setProperty(propertyPath, value)
  },

  /** Update a timer, returns true if timer expired */
  updateTimer(entity: Entity, propertyPath: string, dt: number): boolean {
    const current = entity.getProperty(propertyPath)
    if (typeof current !== 'number') return false

    const newValue = current - dt
    entity.setProperty(propertyPath, newValue)
    return newValue <= 0
  },

  /** Increment a counter */
  incrementCounter(entity: Entity, propertyPath: string): number {
    const current = entity.getProperty(propertyPath)
    const newValue = (typeof current === 'number' ? current : 0) + 1
    entity.setProperty(propertyPath, newValue)
    return newValue
  }
}
