'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import VisualizationLayout from '@/components/ui/VisualizationLayout'
import FileUploadZone from '@/components/ui/FileUploadZone'
import MessageDisplay from '@/components/ui/MessageDisplay'
import type { FileUploadResult } from '@/types'
import CodeBlock from '@/components/ui/CodeBlock'
import {
  SimulationController,
  ABMRenderer,
  createLegend,
  type ABMModelDefinition,
  type SimulationState,
  type TimeseriesData,
  type EntityId,
  type VisualConfig
} from '@/lib/abm'

// Demo models
import { FLOCKING_MODEL } from './demos/flocking'
import { SIR_MODEL } from './demos/sir'
import { PREDATOR_PREY_MODEL } from './demos/predatorPrey'

// =============================================================================
// TYPES
// =============================================================================

interface InspectedEntity {
  id: EntityId
  archetype: string
  components: Record<string, unknown>
}

// =============================================================================
// MAIN COMPONENT
// =============================================================================

export default function ABMPage() {
  // State
  const [model, setModel] = useState<ABMModelDefinition | null>(null)
  const [simState, setSimState] = useState<SimulationState | null>(null)
  const [message, setMessage] = useState<{ text: string; type: 'success' | 'error' | 'info' }>()
  const [timeseries, setTimeseries] = useState<Map<string, TimeseriesData>>(new Map())
  const [inspectedEntity, setInspectedEntity] = useState<InspectedEntity | null>(null)
  const [selectedDemo, setSelectedDemo] = useState<string>('flocking')
  const [showTrails, setShowTrails] = useState(false)
  const [speed, setSpeed] = useState(1)

  // Refs
  const containerRef = useRef<HTMLDivElement>(null)
  const controllerRef = useRef<SimulationController | null>(null)
  const rendererRef = useRef<ABMRenderer | null>(null)
  const animationFrameRef = useRef<number | null>(null)
  const lastTickTimeRef = useRef<number>(0)

  // Demo models map
  const demoModels: Record<string, ABMModelDefinition> = {
    flocking: FLOCKING_MODEL,
    sir: SIR_MODEL,
    predatorPrey: PREDATOR_PREY_MODEL
  }

  // =============================================================================
  // INITIALIZATION
  // =============================================================================

  const initializeSimulation = useCallback(async (modelDef: ABMModelDefinition) => {
    if (!containerRef.current) return

    try {
      // Clean up existing simulation
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
      if (rendererRef.current) {
        rendererRef.current.destroy()
      }

      // Create controller
      const controller = new SimulationController()
      controllerRef.current = controller

      // Initialize simulation
      controller.initialize(modelDef)

      // Get environment config
      const envConfig = controller.getEnvironmentConfig()
      if (!envConfig) throw new Error('No environment config')

      // Create renderer
      const renderer = new ABMRenderer({
        width: envConfig.spatial.width,
        height: envConfig.spatial.height,
        showGrid: envConfig.spatial.type === 'grid2D',
        showTrails: showTrails
      })

      await renderer.initialize(containerRef.current)
      rendererRef.current = renderer

      // Setup environment
      renderer.setupEnvironment(
        envConfig,
        envConfig.features?.zones,
        envConfig.features?.obstacles
      )

      // Set archetype visuals
      const visuals = new Map<string, VisualConfig>()
      for (const archetype of modelDef.overview.entities.archetypes) {
        visuals.set(archetype.name, archetype.visual || {})
      }
      renderer.setArchetypeVisuals(visuals)

      // Subscribe to controller events
      controller.on('stateChanged', (state: unknown) => {
        setSimState({ ...(state as SimulationState) })
      })

      controller.on('tick', () => {
        setTimeseries(new Map(controller.getTimeseries()))
      })

      // Initial render
      renderer.render(controller.getEntities())

      setModel(modelDef)
      setSimState(controller.getState())
      setMessage({ text: `Loaded: ${modelDef.overview.purpose}`, type: 'success' })

    } catch (error) {
      console.error('Failed to initialize simulation:', error)
      setMessage({
        text: `Failed to initialize: ${error instanceof Error ? error.message : 'Unknown error'}`,
        type: 'error'
      })
    }
  }, [showTrails])

  // Load demo on mount and when selection changes
  useEffect(() => {
    const demo = demoModels[selectedDemo]
    if (demo) {
      initializeSimulation(demo)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedDemo])

  // =============================================================================
  // SIMULATION LOOP
  // =============================================================================

  useEffect(() => {
    if (!controllerRef.current || !rendererRef.current) return

    const controller = controllerRef.current
    const renderer = rendererRef.current

    const loop = (timestamp: number) => {
      const state = controller.getState()

      if (!state.paused) {
        // Calculate time since last tick
        const elapsed = timestamp - lastTickTimeRef.current
        const tickInterval = 1000 / (10 * speed) // 10 ticks per second at 1x speed

        if (elapsed >= tickInterval) {
          controller.step()
          lastTickTimeRef.current = timestamp
        }
      }

      // Always render
      renderer.render(controller.getEntities())

      animationFrameRef.current = requestAnimationFrame(loop)
    }

    animationFrameRef.current = requestAnimationFrame(loop)

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
      }
    }
  }, [speed, simState?.paused])

  // =============================================================================
  // CONTROLS
  // =============================================================================

  const handlePlay = () => {
    controllerRef.current?.play()
    lastTickTimeRef.current = performance.now()
  }

  const handlePause = () => {
    controllerRef.current?.pause()
  }

  const handleStep = () => {
    controllerRef.current?.step()
    rendererRef.current?.render(controllerRef.current?.getEntities() || [])
  }

  const handleReset = () => {
    controllerRef.current?.reset()
    rendererRef.current?.clearTrails()
    rendererRef.current?.render(controllerRef.current?.getEntities() || [])
    setTimeseries(new Map())
    setInspectedEntity(null)
  }

  const handleSpeedChange = (newSpeed: number) => {
    setSpeed(newSpeed)
    controllerRef.current?.setSpeed(newSpeed)
  }

  const handleTrailsToggle = () => {
    const newShowTrails = !showTrails
    setShowTrails(newShowTrails)
    rendererRef.current?.updateConfig({ showTrails: newShowTrails })
  }

  // =============================================================================
  // FILE UPLOAD
  // =============================================================================

  const handleFileUpload = (result: FileUploadResult) => {
    if (result.error) {
      setMessage({ text: result.error, type: 'error' })
    } else if (result.data) {
      try {
        // Basic validation
        if (!result.data.overview || !result.data.designConcepts || !result.data.details) {
          throw new Error('Invalid ABM model: missing required sections (overview, designConcepts, details)')
        }

        initializeSimulation(result.data as ABMModelDefinition)
      } catch (error) {
        setMessage({
          text: `Invalid model: ${error instanceof Error ? error.message : 'Unknown error'}`,
          type: 'error'
        })
      }
    }
  }

  // =============================================================================
  // ENTITY INSPECTION
  // =============================================================================

  const handleCanvasClick = (event: React.MouseEvent<HTMLDivElement>) => {
    if (!rendererRef.current || !containerRef.current) return

    const rect = containerRef.current.getBoundingClientRect()
    const x = event.clientX - rect.left
    const y = event.clientY - rect.top

    const entityId = rendererRef.current.getEntityAtPosition(x, y)

    if (entityId) {
      const entity = controllerRef.current?.getEntity(entityId)
      if (entity) {
        const components: Record<string, unknown> = {}
        for (const [type, data] of (entity as any).getAllComponents()) {
          components[type] = data
        }

        setInspectedEntity({
          id: entityId,
          archetype: (entity as any).archetype,
          components
        })
        rendererRef.current.setTrackedEntity(entityId)
      }
    } else {
      setInspectedEntity(null)
      rendererRef.current.setTrackedEntity(null)
    }
  }

  // =============================================================================
  // EXPORT
  // =============================================================================

  const handleExportJSON = () => {
    const json = controllerRef.current?.exportJSON()
    if (json) {
      const blob = new Blob([json], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = 'abm-simulation-export.json'
      a.click()
      URL.revokeObjectURL(url)
    }
  }

  const handleExportCSV = () => {
    const csv = controllerRef.current?.exportCSV()
    if (csv) {
      const blob = new Blob([csv], { type: 'text/csv' })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = 'abm-timeseries.csv'
      a.click()
      URL.revokeObjectURL(url)
    }
  }

  // =============================================================================
  // RENDER
  // =============================================================================

  return (
    <VisualizationLayout
      title="Agent-Based Model Simulator"
      description="Simulate complex systems with interacting agents"
    >
      {/* Demo Selection */}
      <div className="mb-4 flex flex-wrap gap-2 items-center">
        <label className="font-medium">Demo:</label>
        <select
          value={selectedDemo}
          onChange={(e) => setSelectedDemo(e.target.value)}
          className="px-3 py-2 border rounded-md bg-white"
        >
          <option value="flocking">Flocking (Boids)</option>
          <option value="sir">SIR Epidemic</option>
          <option value="predatorPrey">Predator-Prey</option>
        </select>
      </div>

      {/* File Upload */}
      <FileUploadZone
        onFileUpload={handleFileUpload}
        description="Upload an ABM model JSON file"
        className="w-full max-w-2xl mb-4"
      />

      {/* Message Display */}
      {message && (
        <MessageDisplay
          message={message.text}
          type={message.type}
          onClose={() => setMessage(undefined)}
        />
      )}

      {/* Simulation Canvas */}
      <div className="w-full max-w-4xl">
        <div className="bg-gray-900 rounded-lg overflow-hidden relative">
          {/* Canvas Container */}
          <div
            ref={containerRef}
            onClick={handleCanvasClick}
            className="cursor-crosshair"
            style={{ minHeight: 400 }}
          />

          {/* Controls Overlay */}
          <div className="absolute bottom-4 left-4 right-4 flex flex-wrap gap-2 items-center bg-black/50 rounded-lg p-3">
            {/* Playback */}
            <button
              onClick={simState?.paused ? handlePlay : handlePause}
              className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-medium"
            >
              {simState?.paused ? '‚ñ∂ Play' : '‚è∏ Pause'}
            </button>
            <button
              onClick={handleStep}
              className="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-md"
              disabled={!simState?.paused}
            >
              Step
            </button>
            <button
              onClick={handleReset}
              className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-md"
            >
              Reset
            </button>

            {/* Speed */}
            <div className="flex items-center gap-2 ml-4">
              <label className="text-white text-sm">Speed:</label>
              <select
                value={speed}
                onChange={(e) => handleSpeedChange(parseFloat(e.target.value))}
                className="px-2 py-1 rounded bg-gray-700 text-white text-sm"
              >
                <option value={0.5}>0.5x</option>
                <option value={1}>1x</option>
                <option value={2}>2x</option>
              </select>
            </div>

            {/* Trails Toggle */}
            <label className="flex items-center gap-2 ml-4 text-white text-sm cursor-pointer">
              <input
                type="checkbox"
                checked={showTrails}
                onChange={handleTrailsToggle}
                className="rounded"
              />
              Trails
            </label>

            {/* Tick Counter */}
            <div className="ml-auto text-white text-sm">
              Tick: {simState?.tick || 0} | Seed: {simState?.seed || 0}
            </div>
          </div>
        </div>

        {/* Export Buttons */}
        <div className="mt-4 flex gap-2">
          <button
            onClick={handleExportJSON}
            className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-md text-sm"
          >
            üìÑ Export JSON
          </button>
          <button
            onClick={handleExportCSV}
            className="px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-md text-sm"
          >
            üìä Export CSV
          </button>
        </div>
      </div>

      {/* Entity Inspector (floating panel when entity selected) */}
      {inspectedEntity && (
        <div className="w-full max-w-4xl bg-white rounded-lg shadow-lg p-4 mt-4">
          <div className="flex justify-between items-start">
            <h3 className="font-semibold mb-2">Agent Inspector</h3>
            <button
              onClick={() => {
                setInspectedEntity(null)
                rendererRef.current?.setTrackedEntity(null)
              }}
              className="text-gray-400 hover:text-gray-600"
            >
              ‚úï
            </button>
          </div>
          <div className="text-sm grid grid-cols-2 md:grid-cols-4 gap-4">
            <div><strong>ID:</strong> {inspectedEntity.id}</div>
            <div><strong>Type:</strong> {inspectedEntity.archetype}</div>
            {Object.entries(inspectedEntity.components).map(([type, data]) => (
              <div key={type} className="col-span-2 md:col-span-1">
                <div className="font-medium text-blue-600">{type}</div>
                <pre className="text-xs bg-gray-100 p-2 rounded overflow-auto max-h-24">
                  {JSON.stringify(data, null, 2)}
                </pre>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Model Info */}
      {model && (
        <div className="w-full max-w-4xl bg-white rounded-lg shadow-lg p-4 mt-4">
          <h3 className="font-semibold mb-2">Model Info</h3>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
            <div className="md:col-span-2">
              <p className="text-gray-600">{model.overview.purpose}</p>
            </div>
            <div className="flex gap-4">
              <div><strong>Agents:</strong> {controllerRef.current?.getEntities().length || 0}</div>
              <div><strong>dt:</strong> {model.overview.scales.temporal.dt}</div>
            </div>
          </div>
        </div>
      )}

      {/* Timeseries Plots - Two vertical graphs */}
      <div className="w-full max-w-4xl mt-8 grid grid-cols-1 gap-4">
        {/* Aggregate/Population-level Plot */}
        <div className="bg-white rounded-lg shadow-lg p-4">
          <h3 className="font-semibold mb-2">Population Dynamics (Aggregate)</h3>
          <p className="text-xs text-gray-500 mb-2">Shows total counts and population-level metrics over time</p>
          <div className="h-48 relative">
            {timeseries.size > 0 ? (
              <TimeseriesPlot data={timeseries} type="aggregate" />
            ) : (
              <div className="h-full flex items-center justify-center text-gray-400">
                Run simulation to see population data
              </div>
            )}
          </div>
        </div>

        {/* Individual Agent-level Plot */}
        <div className="bg-white rounded-lg shadow-lg p-4">
          <h3 className="font-semibold mb-2">Agent-Level Metrics (Individual)</h3>
          <p className="text-xs text-gray-500 mb-2">Shows average values and distributions across individual agents</p>
          <div className="h-48 relative">
            {timeseries.size > 0 ? (
              <TimeseriesPlot data={timeseries} type="individual" />
            ) : (
              <div className="h-full flex items-center justify-center text-gray-400">
                Run simulation to see agent-level data
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Instructions */}
      <div className="w-full max-w-4xl bg-white rounded-lg shadow-lg p-4 mt-4">
        <h3 className="font-semibold mb-2">Instructions</h3>
        <ul className="text-sm text-gray-600 space-y-1 list-disc list-inside grid grid-cols-1 md:grid-cols-2">
          <li>Select a demo or upload a custom JSON model</li>
          <li>Click Play to start the simulation</li>
          <li>Click on agents to inspect their state</li>
          <li>Use Speed control to slow down or speed up</li>
          <li>Enable Trails to see agent movement history</li>
          <li>Export data as JSON or CSV for analysis</li>
        </ul>
      </div>

      {/* Example JSON Format */}
      <div className="w-full max-w-4xl mt-8">
        <h3 className="text-lg font-semibold mb-4">Expected JSON Format:</h3>
        <p className="text-sm text-gray-600 mb-3">
          ABM models follow the ODD (Overview, Design concepts, Details) protocol structure.
        </p>
        <CodeBlock
          code={{
            "schemaVersion": "1.0",
            "overview": {
              "purpose": "Example flocking behavior simulation",
              "entities": {
                "componentTypes": [
                  { "name": "Position", "properties": { "x": { "type": "number" }, "y": { "type": "number" } } },
                  { "name": "Velocity", "properties": { "x": { "type": "number" }, "y": { "type": "number" } } }
                ],
                "archetypes": [
                  {
                    "name": "Boid",
                    "components": {
                      "Position": { "x": 0, "y": 0 },
                      "Velocity": { "x": 0, "y": 0 }
                    },
                    "visual": { "shape": "triangle", "size": 8, "color": "#4285f4" }
                  }
                ]
              },
              "scales": {
                "spatial": { "type": "continuous2D", "width": 800, "height": 600 },
                "temporal": { "dt": 0.1 }
              },
              "processSchedule": [{ "system": "movement" }, { "system": "rules" }]
            },
            "designConcepts": {
              "interaction": {
                "rules": [
                  {
                    "name": "separation",
                    "trigger": { "onProximity": { "radius": 25 } },
                    "effect": { "increment": { "target": "self.Velocity.x", "amount": { "prop": "separation.x" } } }
                  }
                ]
              },
              "observation": {
                "timeseries": [{ "name": "count", "query": { "count": {} } }]
              }
            },
            "details": {
              "initialization": {
                "entities": [
                  { "archetype": "Boid", "count": 50, "position": { "type": "random" } }
                ]
              }
            }
          }}
        />
        <div className="mt-6 p-4 bg-blue-50 rounded-lg">
          <h4 className="font-semibold mb-2">Key Features:</h4>
          <ul className="list-disc list-inside text-sm space-y-1">
            <li><strong>overview</strong>: Entity types, archetypes, environment size, and process schedule</li>
            <li><strong>designConcepts</strong>: Interaction rules with triggers (everyTick, onProximity, onEvent) and effects</li>
            <li><strong>details</strong>: Initial entity spawning configuration</li>
            <li>Rules use expression trees (no code) for conditions and effects</li>
            <li>Supports steering behaviors: seek, flee, separation, alignment, cohesion, wander</li>
          </ul>
        </div>
      </div>
    </VisualizationLayout>
  )
}

// =============================================================================
// TIMESERIES PLOT COMPONENT
// =============================================================================

interface TimeseriesPlotProps {
  data: Map<string, TimeseriesData>
  type: 'aggregate' | 'individual'
}

function TimeseriesPlot({ data, type }: TimeseriesPlotProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    const rect = canvas.getBoundingClientRect()
    canvas.width = rect.width * window.devicePixelRatio
    canvas.height = rect.height * window.devicePixelRatio
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio)

    const width = rect.width
    const height = rect.height
    const padding = 40

    // Clear
    ctx.fillStyle = '#f9fafb'
    ctx.fillRect(0, 0, width, height)

    // Filter data based on type
    // Aggregate: population counts, totals (names containing 'count', 'total', 'population')
    // Individual: averages, per-agent metrics (names containing 'avg', 'mean', 'individual')
    const filteredData = new Map<string, TimeseriesData>()
    const aggregateKeywords = ['count', 'total', 'population', 'susceptible', 'infected', 'recovered', 'prey', 'predator', 'boid']
    const individualKeywords = ['avg', 'mean', 'average', 'speed', 'energy', 'distance']

    data.forEach((ts, name) => {
      const nameLower = name.toLowerCase()
      if (type === 'aggregate') {
        // Include if matches aggregate keywords OR doesn't match individual keywords
        const isAggregate = aggregateKeywords.some(kw => nameLower.includes(kw))
        const isIndividual = individualKeywords.some(kw => nameLower.includes(kw))
        if (isAggregate || !isIndividual) {
          filteredData.set(name, ts)
        }
      } else {
        // Individual: include if matches individual keywords
        const isIndividual = individualKeywords.some(kw => nameLower.includes(kw))
        if (isIndividual) {
          filteredData.set(name, ts)
        }
      }
    })

    // If no filtered data for individual, show all data but labeled differently
    const displayData = filteredData.size > 0 ? filteredData : (type === 'aggregate' ? data : new Map())

    if (displayData.size === 0) {
      ctx.fillStyle = '#9ca3af'
      ctx.font = '14px sans-serif'
      ctx.textAlign = 'center'
      ctx.fillText(
        type === 'individual' ? 'No individual-level metrics defined' : 'No data available',
        width / 2,
        height / 2
      )
      return
    }

    // Find data range
    let minVal = Infinity
    let maxVal = -Infinity
    let maxTick = 0

    displayData.forEach(ts => {
      for (const v of ts.values) {
        minVal = Math.min(minVal, v)
        maxVal = Math.max(maxVal, v)
      }
      maxTick = Math.max(maxTick, ts.ticks.length > 0 ? ts.ticks[ts.ticks.length - 1] : 0)
    })

    if (minVal === Infinity) return

    // Add padding to range
    const range = maxVal - minVal || 1
    minVal -= range * 0.1
    maxVal += range * 0.1

    // Draw axes
    ctx.strokeStyle = '#ccc'
    ctx.lineWidth = 1
    ctx.beginPath()
    ctx.moveTo(padding, padding)
    ctx.lineTo(padding, height - padding)
    ctx.lineTo(width - padding, height - padding)
    ctx.stroke()

    // Draw axis labels
    ctx.fillStyle = '#666'
    ctx.font = '10px sans-serif'
    ctx.textAlign = 'center'
    ctx.fillText('Time (ticks)', width / 2, height - 5)
    ctx.save()
    ctx.translate(12, height / 2)
    ctx.rotate(-Math.PI / 2)
    ctx.fillText(type === 'aggregate' ? 'Count' : 'Value', 0, 0)
    ctx.restore()

    // Colors for each series
    const colors = type === 'aggregate'
      ? ['#4285f4', '#ea4335', '#fbbc04', '#34a853', '#ff6d01', '#9b59b6']
      : ['#8e44ad', '#16a085', '#e67e22', '#2980b9', '#c0392b']
    let colorIndex = 0

    // Draw data
    displayData.forEach((ts, name) => {
      if (ts.values.length < 2) return

      ctx.strokeStyle = colors[colorIndex % colors.length]
      ctx.lineWidth = 2
      ctx.beginPath()

      for (let i = 0; i < ts.values.length; i++) {
        const x = padding + (ts.ticks[i] / maxTick) * (width - 2 * padding)
        const y = height - padding - ((ts.values[i] - minVal) / (maxVal - minVal)) * (height - 2 * padding)

        if (i === 0) {
          ctx.moveTo(x, y)
        } else {
          ctx.lineTo(x, y)
        }
      }

      ctx.stroke()
      colorIndex++
    })

    // Draw legend
    colorIndex = 0
    let legendY = 10
    const legendX = width - 120
    displayData.forEach((ts, name) => {
      ctx.fillStyle = colors[colorIndex % colors.length]
      ctx.fillRect(legendX, legendY, 12, 12)
      ctx.fillStyle = '#333'
      ctx.font = '11px sans-serif'
      ctx.textAlign = 'left'
      // Truncate long names
      const displayName = name.length > 12 ? name.slice(0, 10) + '...' : name
      ctx.fillText(displayName, legendX + 16, legendY + 10)
      legendY += 16
      colorIndex++
    })

  }, [data, type])

  return (
    <canvas
      ref={canvasRef}
      className="w-full h-full"
    />
  )
}
