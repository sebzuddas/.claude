'use client'

import { useEffect, useRef, useState } from 'react'
import type { StateSpaceData, VisualizationProps } from '@/types'

interface StateSpaceVisualizationProps extends VisualizationProps {
  data: StateSpaceData
}

export default function StateSpaceVisualization({
  data,
  width = 1200,
  height = 800,
  onError
}: StateSpaceVisualizationProps) {
  const canvasRef = useRef<HTMLDivElement>(null)
  const [p5Instance, setP5Instance] = useState<any>(null)
  const [currentTimeIndex, setCurrentTimeIndex] = useState(0)
  const currentTimeIndexRef = useRef(0)
  const [isPlaying, setIsPlaying] = useState(false)
  const [selectedStates, setSelectedStates] = useState<number[]>([])
  const [trailLength, setTrailLength] = useState(50)

  // Sync state to ref
  useEffect(() => {
    currentTimeIndexRef.current = currentTimeIndex
  }, [currentTimeIndex])

  // Initialize selected states (all states by default)
  useEffect(() => {
    if (data?.x && data.x.length > 0) {
      const numStates = data.x[0].length
      setSelectedStates(Array.from({ length: numStates }, (_, i) => i))
    }
  }, [data])

  // Auto-play animation
  useEffect(() => {
    if (!isPlaying || !data) return

    const interval = setInterval(() => {
      setCurrentTimeIndex((prev) => {
        if (!data) return prev
        const next = prev + 1
        if (next >= data.t.length) {
          setIsPlaying(false)
          return prev
        }
        return next
      })
    }, 50) // Update every 50ms

    return () => clearInterval(interval)
  }, [isPlaying, data])

  // P5.js visualization
  useEffect(() => {
    let p5: any
    let isMounted = true

    const loadP5 = async () => {
      if (typeof window !== 'undefined' && canvasRef.current) {
        canvasRef.current.innerHTML = ''

        const p5Module = await import('p5')
        const P5 = p5Module.default

        if (!isMounted) return

        const sketch = (p: any) => {
          p.setup = () => {
            const canvas = p.createCanvas(width, height - 150)
            canvas.parent(canvasRef.current)
            canvas.style('display', 'block')
            canvas.style('margin', '0 auto')

            p.textAlign(p.CENTER, p.CENTER)
            p.frameRate(30)
          }

          p.draw = () => {
            p.background(250)

            if (!data || data.x.length === 0) {
              p.fill(150)
              p.textSize(16)
              p.text('No data loaded', width / 2, height / 2)
              return
            }

            const currentIdx = currentTimeIndexRef.current
            const numStates = data.x[0].length
            const selected = selectedStates.length > 0 ? selectedStates : Array.from({ length: numStates }, (_, i) => i)

            // Calculate grid layout
            const gridSize = selected.length
            const plotsPerRow = Math.ceil(Math.sqrt(gridSize * (gridSize - 1) / 2))
            const plotWidth = width / plotsPerRow
            const plotHeight = (height - 150) / Math.ceil((gridSize * (gridSize - 1) / 2) / plotsPerRow)

            // Draw all state pairs (upper triangle only)
            let plotIndex = 0
            for (let i = 0; i < selected.length; i++) {
              for (let j = i + 1; j < selected.length; j++) {
                const stateI = selected[i]
                const stateJ = selected[j]

                const row = Math.floor(plotIndex / plotsPerRow)
                const col = plotIndex % plotsPerRow
                const x = col * plotWidth
                const y = row * plotHeight

                drawPhasePlot(p, data, stateI, stateJ, x, y, plotWidth, plotHeight, currentIdx, trailLength)
                plotIndex++
              }
            }

            // Draw time indicator
            const currentTime = data.t[currentIdx]
            p.fill(60)
            p.textSize(14)
            p.textAlign(p.RIGHT, p.TOP)
            p.text(`t = ${currentTime.toFixed(2)}s`, width - 20, 10)

            // Draw title
            if (data.title) {
              p.fill(60)
              p.textSize(18)
              p.textAlign(p.CENTER, p.TOP)
              p.text(data.title, width / 2, 10)
            }
          }

          function drawPhasePlot(
            p: any,
            data: StateSpaceData,
            stateI: number,
            stateJ: number,
            x: number,
            y: number,
            w: number,
            h: number,
            currentIdx: number,
            trailLen: number
          ) {
            const padding = 40
            const plotX = x + padding / 2
            const plotY = y + padding / 2
            const plotW = w - padding
            const plotH = h - padding

            // Get data ranges
            const xData = data.x.map(row => row[stateJ])
            const yData = data.x.map(row => row[stateI])

            const xMin = Math.min(...xData)
            const xMax = Math.max(...xData)
            const yMin = Math.min(...yData)
            const yMax = Math.max(...yData)

            const xRange = xMax - xMin
            const yRange = yMax - yMin

            const xPadding = xRange * 0.1
            const yPadding = yRange * 0.1

            // Map function
            const mapX = (val: number) => p.map(val, xMin - xPadding, xMax + xPadding, plotX, plotX + plotW)
            const mapY = (val: number) => p.map(val, yMin - yPadding, yMax + yPadding, plotY + plotH, plotY)

            // Draw axes
            p.stroke(200)
            p.strokeWeight(1)
            p.line(plotX, plotY + plotH / 2, plotX + plotW, plotY + plotH / 2) // X-axis
            p.line(plotX + plotW / 2, plotY, plotX + plotW / 2, plotY + plotH) // Y-axis

            // Draw border
            p.stroke(100)
            p.noFill()
            p.rect(plotX, plotY, plotW, plotH)

            // Draw trajectory trail
            p.noFill()
            p.strokeWeight(1.5)
            for (let t = Math.max(0, currentIdx - trailLen); t < currentIdx; t++) {
              const alpha = p.map(t, currentIdx - trailLen, currentIdx, 50, 200)
              p.stroke(100, 150, 255, alpha)
              const x1 = mapX(xData[t])
              const y1 = mapY(yData[t])
              const x2 = mapX(xData[t + 1])
              const y2 = mapY(yData[t + 1])
              p.line(x1, y1, x2, y2)
            }

            // Draw complete trajectory (faint)
            p.stroke(200, 200, 200, 100)
            p.strokeWeight(0.5)
            p.beginShape()
            for (let t = 0; t < data.x.length; t++) {
              const px = mapX(xData[t])
              const py = mapY(yData[t])
              p.vertex(px, py)
            }
            p.endShape()

            // Draw current point
            const currentX = mapX(xData[currentIdx])
            const currentY = mapY(yData[currentIdx])
            p.fill(255, 100, 100)
            p.noStroke()
            p.circle(currentX, currentY, 8)

            // Draw starting point
            p.fill(100, 255, 100)
            p.circle(mapX(xData[0]), mapY(yData[0]), 6)

            // Labels
            const labelI = data.labels?.[stateI] || `x${stateI + 1}`
            const labelJ = data.labels?.[stateJ] || `x${stateJ + 1}`

            p.fill(60)
            p.noStroke()
            p.textSize(11)
            p.textAlign(p.CENTER, p.TOP)
            p.text(labelJ, plotX + plotW / 2, plotY + plotH + 5)

            p.push()
            p.translate(plotX - 20, plotY + plotH / 2)
            p.rotate(-p.HALF_PI)
            p.textAlign(p.CENTER, p.TOP)
            p.text(labelI, 0, 0)
            p.pop()
          }
        }

        p5 = new P5(sketch)
        setP5Instance(p5)
      }
    }

    loadP5()

    return () => {
      isMounted = false
      if (p5) {
        p5.remove()
      }
    }
  }, [data, width, height, selectedStates, trailLength])

  const handlePlayPause = () => {
    if (!data) return

    if (currentTimeIndex >= data.t.length - 1) {
      setCurrentTimeIndex(0)
      setIsPlaying(true)
    } else {
      setIsPlaying(!isPlaying)
    }
  }

  const handleStepForward = () => {
    if (!data) return
    setCurrentTimeIndex(Math.min(currentTimeIndex + 1, data.t.length - 1))
  }

  const handleStepBackward = () => {
    setCurrentTimeIndex(Math.max(currentTimeIndex - 1, 0))
  }

  const handleReset = () => {
    setCurrentTimeIndex(0)
    setIsPlaying(false)
  }

  const handleScrub = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = parseInt(e.target.value)
    setCurrentTimeIndex(value)
  }

  const toggleState = (stateIndex: number) => {
    setSelectedStates(prev => {
      if (prev.includes(stateIndex)) {
        const newSelection = prev.filter(i => i !== stateIndex)
        return newSelection.length >= 2 ? newSelection : prev // Keep at least 2 states
      } else {
        return [...prev, stateIndex].sort((a, b) => a - b)
      }
    })
  }

  const numStates = data?.x?.[0]?.length || 0

  return (
    <div className="w-full">
      <div ref={canvasRef} />

      {/* Controls */}
      <div className="mt-4 p-4 bg-gray-100 rounded-lg">
        {/* State Selection */}
        {numStates > 0 && (
          <div className="mb-4 pb-3 border-b border-gray-300">
            <h3 className="text-sm font-semibold mb-2">Select States to Display:</h3>
            <div className="flex flex-wrap gap-2">
              {Array.from({ length: numStates }, (_, i) => {
                const label = data.labels?.[i] || `x${i + 1}`
                const isSelected = selectedStates.includes(i)
                return (
                  <button
                    key={i}
                    onClick={() => toggleState(i)}
                    className={`px-3 py-1 rounded text-sm transition-colors ${
                      isSelected
                        ? 'bg-blue-500 text-white'
                        : 'bg-gray-300 text-gray-700 hover:bg-gray-400'
                    }`}
                    disabled={isSelected && selectedStates.length <= 2}
                  >
                    {label}
                  </button>
                )
              })}
            </div>
            <div className="mt-2">
              <label className="text-sm">
                Trail Length: {trailLength}
                <input
                  type="range"
                  min="10"
                  max="200"
                  value={trailLength}
                  onChange={(e) => setTrailLength(parseInt(e.target.value))}
                  className="ml-2 w-48"
                />
              </label>
            </div>
          </div>
        )}

        {/* Playback Controls */}
        <div className="flex items-center justify-center gap-4 mb-3">
          <button
            onClick={handleReset}
            className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
            disabled={!data}
          >
            Reset
          </button>

          <button
            onClick={handleStepBackward}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
            disabled={!data || currentTimeIndex === 0}
          >
            ← Step
          </button>

          <button
            onClick={handlePlayPause}
            className="px-6 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors font-semibold"
            disabled={!data}
          >
            {isPlaying ? 'Pause' : 'Play'}
          </button>

          <button
            onClick={handleStepForward}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
            disabled={!data || currentTimeIndex >= (data?.t.length ?? 0) - 1}
          >
            Step →
          </button>
        </div>

        {/* Timeline scrubber */}
        {data && (
          <div className="w-full">
            <input
              type="range"
              min={0}
              max={data.t.length - 1}
              value={currentTimeIndex}
              onChange={handleScrub}
              className="w-full"
            />
            <div className="flex justify-between text-xs text-gray-600 mt-1">
              <span>0s</span>
              <span>{data.t[data.t.length - 1].toFixed(1)}s</span>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
