/**
 * Agent-Based Modeling (ABM) Type Definitions
 *
 * Based on ECS pattern and ODD protocol structure
 */

// =============================================================================
// CORE ECS TYPES
// =============================================================================

/** Unique entity identifier */
export type EntityId = string

/** Component type name (e.g., "Position", "Velocity", "Health") */
export type ComponentType = string

/** Property path for accessing nested values (e.g., "self.Health.value") */
export type PropertyPath = string

// =============================================================================
// DATA TYPES FOR COMPONENT PROPERTIES
// =============================================================================

export type ABMDataType =
  | 'number'
  | 'string'
  | 'boolean'
  | 'enum'
  | 'vector2D'
  | 'entityRef'
  | 'entityRefArray'

export interface Vector2D {
  x: number
  y: number
}

export interface PropertySchema {
  type: ABMDataType
  default?: unknown
  min?: number
  max?: number
  enumValues?: string[]
}

// =============================================================================
// COMPONENT DEFINITIONS
// =============================================================================

export interface ComponentTypeDefinition {
  name: string
  properties: Record<string, PropertySchema>
}

/** Runtime component data - just key-value pairs */
export type ComponentData = Record<string, any>

// =============================================================================
// ARCHETYPE DEFINITIONS
// =============================================================================

export interface ArchetypeDefinition {
  name: string
  extends?: string
  components: Record<ComponentType, ComponentData>
  visual?: VisualConfig
}

export interface VisualConfig {
  shape?: 'circle' | 'square' | 'triangle' | 'diamond' | 'icon'
  iconUrl?: string
  size?: number
  color?: string
  colorByState?: {
    property: PropertyPath
    minColor: string
    maxColor: string
  }
}

// =============================================================================
// ENTITY INITIALIZATION
// =============================================================================

export interface EntitySpawnConfig {
  archetype: string
  count?: number
  individual?: boolean
  position?: {
    type: 'random' | 'grid' | 'cluster' | 'fixed'
    value?: Vector2D | Vector2D[]
    region?: { min: Vector2D; max: Vector2D }
    spacing?: number
  }
  propertyVariation?: Record<PropertyPath, {
    distribution: 'uniform' | 'normal' | 'fixed'
    min?: number
    max?: number
    mean?: number
    stdDev?: number
    value?: unknown
  }>
}

// =============================================================================
// ENVIRONMENT TYPES
// =============================================================================

export type SpatialType = 'continuous2D' | 'grid2D' | 'network'
export type BoundaryType = 'toroidal' | 'bounded' | 'infinite'

export interface EnvironmentConfig {
  spatial: {
    type: SpatialType
    width: number
    height: number
    cellSize?: number // for grid2D
  }
  boundary: BoundaryType
  features?: {
    obstacles?: ObstacleDefinition[]
    zones?: ZoneDefinition[]
    resourceFields?: ResourceFieldDefinition[]
  }
}

export interface ObstacleDefinition {
  id: string
  shape: 'rectangle' | 'circle'
  position: Vector2D
  size: Vector2D | number // Vector2D for rectangle, number for circle radius
}

export interface ZoneDefinition {
  id: string
  name: string
  shape: 'rectangle' | 'circle'
  position: Vector2D
  size: Vector2D | number
  properties?: Record<string, unknown>
}

export interface ResourceFieldDefinition {
  id: string
  name: string
  initialValue: number | 'random'
  regenerationRate?: number
  maxValue?: number
}

// =============================================================================
// CONDITION EXPRESSIONS (PREDICATE TREES)
// =============================================================================

export type ConditionExpression =
  | { and: ConditionExpression[] }
  | { or: ConditionExpression[] }
  | { not: ConditionExpression }
  | { eq: [ValueExpression, ValueExpression] }
  | { neq: [ValueExpression, ValueExpression] }
  | { gt: [ValueExpression, ValueExpression] }
  | { gte: [ValueExpression, ValueExpression] }
  | { lt: [ValueExpression, ValueExpression] }
  | { lte: [ValueExpression, ValueExpression] }
  | { hasComponent: string }
  | { inZone: string }
  | { withinRadius: { center: ValueExpression; radius: ValueExpression } }
  | boolean

export type ValueExpression =
  | { prop: PropertyPath }
  | { add: [ValueExpression, ValueExpression] }
  | { sub: [ValueExpression, ValueExpression] }
  | { mul: [ValueExpression, ValueExpression] }
  | { div: [ValueExpression, ValueExpression] }
  | { mod: [ValueExpression, ValueExpression] }
  | { abs: ValueExpression }
  | { floor: ValueExpression }
  | { ceil: ValueExpression }
  | { round: ValueExpression }
  | { min: ValueExpression[] }
  | { max: ValueExpression[] }
  | { lerp: { a: ValueExpression; b: ValueExpression; t: ValueExpression } }
  | { clamp: { value: ValueExpression; min: ValueExpression; max: ValueExpression } }
  | { noise: { x: ValueExpression; y?: ValueExpression } }
  | { random: { min?: ValueExpression; max?: ValueExpression } }
  | { distance: { from: ValueExpression; to: ValueExpression } }
  | { count: { filter?: ConditionExpression } }
  | { average: { property: PropertyPath; filter?: ConditionExpression } }
  | { sum: { property: PropertyPath; filter?: ConditionExpression } }
  | { nearest: { n?: number; filter?: ConditionExpression } }
  | number
  | string
  | boolean

// =============================================================================
// EFFECT EXPRESSIONS (OPERATION TREES)
// =============================================================================

export type EffectExpression =
  | { set: { target: PropertyPath; value: ValueExpression } }
  | { increment: { target: PropertyPath; amount: ValueExpression } }
  | { decrement: { target: PropertyPath; amount: ValueExpression } }
  | { transition: { target: PropertyPath; to: string } }
  | { spawn: { archetype: string; position?: ValueExpression; properties?: Record<PropertyPath, ValueExpression> } }
  | { destroy: { target?: 'self' | 'other' | EntityId } }
  | { emit: { event: string; data?: Record<string, ValueExpression> } }
  | { sequence: EffectExpression[] }
  | { conditional: { condition: ConditionExpression; then: EffectExpression; else?: EffectExpression } }
  | { probability: { chance: ValueExpression; effect: EffectExpression } }

// =============================================================================
// RULE DEFINITIONS
// =============================================================================

export type TriggerType =
  | { everyTick: true }
  | { onProximity: { radius: number; filter?: ConditionExpression } }
  | { onStateChange: { property: PropertyPath } }
  | { onEvent: { event: string } }

export interface RuleDefinition {
  name: string
  description?: string
  trigger: TriggerType
  appliesTo?: ConditionExpression // Filter which entities this rule applies to
  condition?: ConditionExpression
  effect: EffectExpression
}

// =============================================================================
// STEERING BEHAVIORS
// =============================================================================

export type SteeringBehaviorType =
  | 'seek'
  | 'flee'
  | 'arrive'
  | 'wander'
  | 'separation'
  | 'alignment'
  | 'cohesion'
  | 'pursuit'
  | 'evade'

export interface SteeringRule {
  type: SteeringBehaviorType
  weight: number
  query?: {
    radius?: number
    filter?: ConditionExpression
    target?: ValueExpression // For seek/flee/pursue/evade
  }
  params?: {
    slowingRadius?: number // For arrive
    wanderRadius?: number
    wanderDistance?: number
    wanderJitter?: number
  }
}

export interface SteeringBehaviorComponent {
  rules: SteeringRule[]
  maxSpeed?: number
  maxForce?: number
}

// =============================================================================
// PROCESS SCHEDULING
// =============================================================================

export type SystemOrder = 'parallel' | 'sequential'

export interface ProcessScheduleEntry {
  system: string
  order?: SystemOrder
  shuffle?: boolean
}

// =============================================================================
// OBSERVATION & OUTPUT
// =============================================================================

export interface TimeseriesObservation {
  name: string
  query: ValueExpression
}

export interface SnapshotConfig {
  every: number
  include: ComponentType[]
}

export interface ObservationConfig {
  timeseries?: TimeseriesObservation[]
  snapshots?: SnapshotConfig
  events?: string[]
}

// =============================================================================
// UI PARAMETERS
// =============================================================================

export interface UIParameter {
  name: string
  path: PropertyPath
  type: 'number' | 'boolean' | 'enum'
  min?: number
  max?: number
  step?: number
  enumValues?: string[]
  description?: string
}

// =============================================================================
// ODD PROTOCOL STRUCTURE
// =============================================================================

export interface ABMOverview {
  purpose: string
  entities: {
    componentTypes: ComponentTypeDefinition[]
    archetypes: ArchetypeDefinition[]
  }
  scales: {
    spatial: EnvironmentConfig
    temporal: {
      dt: number
      maxTicks?: number
      maxTime?: number
    }
  }
  processSchedule: ProcessScheduleEntry[]
}

export interface ABMDesignConcepts {
  sensing?: {
    description?: string
    defaultRadius?: number
  }
  interaction?: {
    description?: string
    rules: RuleDefinition[]
  }
  stochasticity?: {
    seed?: number
    description?: string
  }
  observation?: ObservationConfig
}

export interface ABMDetails {
  initialization: {
    entities: EntitySpawnConfig[]
    environmentSetup?: Record<string, unknown>
  }
  submodels?: Record<string, {
    type: string
    [key: string]: unknown
  }>
  interventions?: Array<{
    name: string
    triggerTick?: number
    triggerCondition?: ConditionExpression
    effect: EffectExpression
  }>
}

// =============================================================================
// COMPLETE ABM MODEL DEFINITION
// =============================================================================

export interface ABMModelDefinition {
  schemaVersion: string
  overview: ABMOverview
  designConcepts: ABMDesignConcepts
  details: ABMDetails
  uiParameters?: UIParameter[]
}

// =============================================================================
// RUNTIME STATE
// =============================================================================

export interface Entity {
  readonly id: EntityId
  archetype: string
  hasComponent(type: ComponentType): boolean
  getComponent<T = ComponentData>(type: ComponentType): T | undefined
  setComponent(type: ComponentType, data: ComponentData): void
  removeComponent(type: ComponentType): boolean
  getComponentTypes(): ComponentType[]
  getAllComponents(): Map<ComponentType, ComponentData>
  getProperty(path: string): unknown
  setProperty(path: string, value: unknown): boolean
}

export interface SimulationState {
  tick: number
  time: number
  entities: Map<EntityId, Entity>
  spatialIndex: SpatialIndex
  eventQueue: SimulationEvent[]
  timeseries: Map<string, number[]>
  eventLog: SimulationEvent[]
  seed: number
  rng: () => number
  paused: boolean
  speed: number
}

export interface SimulationEvent {
  tick: number
  event: string
  entityId?: EntityId
  data?: Record<string, unknown>
}

export interface SpatialIndex {
  type: SpatialType
  query(position: Vector2D, radius: number): EntityId[]
  update(entityId: EntityId, position: Vector2D): void
  remove(entityId: EntityId): void
  insert(entityId: EntityId, position: Vector2D): void
  clear(): void
}

// =============================================================================
// RENDERER TYPES
// =============================================================================

export interface RenderConfig {
  width: number
  height: number
  backgroundColor?: string
  showGrid?: boolean
  showZones?: boolean
  showTrails?: boolean
  trailLength?: number
}

export interface AgentRenderState {
  entityId: EntityId
  position: Vector2D
  visual: VisualConfig
  tracked?: boolean
}

// =============================================================================
// VALIDATION
// =============================================================================

export interface ValidationError {
  path: string
  message: string
  line?: number
}

export interface ValidationResult {
  valid: boolean
  errors: ValidationError[]
}
