     1→'use client'
     2→
     3→import { useEffect, useRef, useState } from 'react'
     4→import type { SystemModelData, VisualizationProps } from '@/types'
     5→
     6→interface SystemModelProps extends VisualizationProps {
     7→  data: SystemModelData
     8→}
     9→
    10→// Simulation result storing all time steps
    11→interface SimulationResult {
    12→  t: number[]      // Time points
    13→  x: number[][]    // State trajectories [timeStep][stateIndex]
    14→  u: number[][]    // Input trajectories [timeStep][inputIndex]
    15→  y: number[][]    // Output trajectories [timeStep][outputIndex]
    16→}
    17→
    18→// Node for visualization
    19→interface Node {
    20→  id: string
    21→  type: 'input' | 'state' | 'output'
    22→  index: number
    23→  label: string
    24→  x: number
    25→  y: number
    26→  value: number
    27→}
    28→
    29→// Edge for visualization
    30→interface Edge {
    31→  from: Node
    32→  to: Node
    33→  weight: number
    34→  flowRate: number
    35→  bidirectional: boolean      // True if this edge should curve (for bidirectional edges)
    36→  parallelOffset: number  // Offset for curve (positive = curve up/right)
    37→}
    38→
    39→// Particle for flow animation
    40→interface Particle {
    41→  edge: Edge
    42→  progress: number  // 0 to 1
    43→  active: boolean
    44→}
    45→
    46→// Constants for pipe visualization
    47→const PARTICLE_SIZE = 6
    48→const PIPE_WIDTH = 8  // Slightly larger than particle for pipe effect
    49→const BIDIRECTIONAL_OFFSET = 15  // Offset for parallel pipes in bidirectional edges (increased for visibility)
    50→
    51→export default function SystemModel({
    52→  data,
    53→  width = 1200,
    54→  height = 800,
    55→  onError
    56→}: SystemModelProps) {
    57→  const canvasRef = useRef<HTMLDivElement>(null)
    58→  const controlsRef = useRef<HTMLDivElement>(null)
    59→  const [p5Instance, setP5Instance] = useState<any>(null)
    60→  const simulationRef = useRef<SimulationResult | null>(null)
    61→  const [currentTimeIndex, setCurrentTimeIndex] = useState(0)
    62→  const currentTimeIndexRef = useRef(0) // Ref for P5 to read without re-mounting
    63→  const [isPlaying, setIsPlaying] = useState(false)
    64→  const [simulationError, setSimulationError] = useState<string | null>(null)
    65→  const simulationErrorRef = useRef<string | null>(null) // Ref for P5 to read
    66→
    67→  // Sync state to refs so P5 can read without re-mounting
    68→  useEffect(() => {
    69→    currentTimeIndexRef.current = currentTimeIndex
    70→  }, [currentTimeIndex])
    71→
    72→  useEffect(() => {
    73→    simulationErrorRef.current = simulationError
    74→  }, [simulationError])
    75→
    76→  // Run simulation when data changes
    77→  useEffect(() => {
    78→    if (!data) return
    79→
    80→    try {
    81→      const result = runSimulation(data)
    82→      simulationRef.current = result
    83→      setCurrentTimeIndex(0)
    84→      currentTimeIndexRef.current = 0
    85→      setSimulationError(null)
    86→      simulationErrorRef.current = null
    87→    } catch (error) {
    88→      const errorMsg = error instanceof Error ? error.message : 'Simulation failed'
    89→      setSimulationError(errorMsg)
    90→      simulationErrorRef.current = errorMsg
    91→      onError?.(errorMsg)
    92→    }
    93→  }, [data, onError])
    94→
    95→  // Auto-play animation
    96→  useEffect(() => {
    97→    if (!isPlaying || !simulationRef.current) return
    98→
    99→    const interval = setInterval(() => {
   100→      setCurrentTimeIndex((prev) => {
   101→        if (!simulationRef.current) return prev
   102→        const next = prev + 1
   103→        if (next >= simulationRef.current.t.length) {
   104→          setIsPlaying(false)
   105→          return prev
   106→        }
   107→        return next
   108→      })
   109→    }, 50) // Update every 50ms
   110→
   111→    return () => clearInterval(interval)
   112→  }, [isPlaying])
   113→
   114→  // P5.js visualization
   115→  useEffect(() => {
   116→    let p5: any
   117→    let isMounted = true
   118→
   119→    const loadP5 = async () => {
   120→      if (typeof window !== 'undefined' && canvasRef.current) {
   121→        canvasRef.current.innerHTML = ''
   122→
   123→        const p5Module = await import('p5')
   124→        const P5 = p5Module.default
   125→
   126→        if (!isMounted) return
   127→
   128→        const sketch = (p: any) => {
   129→          let nodes: Node[] = []
   130→          let edges: Edge[] = []
   131→          const particlePool: Particle[] = []
   132→
   133→          p.setup = () => {
   134→            const canvas = p.createCanvas(width, height - 100) // Reserve space for controls
   135→            canvas.parent(canvasRef.current)
   136→            canvas.style('display', 'block')
   137→            canvas.style('margin', '0 auto')
   138→
   139→            p.textAlign(p.CENTER, p.CENTER)
   140→
   141→            // Initialize layout
   142→            if (simulationRef.current && data) {
   143→              const layout = createNeuralNetworkLayout(data, simulationRef.current, width, height - 100)
   144→              nodes = layout.nodes
   145→              edges = layout.edges
   146→
   147→              // Initialize fixed particles per edge (conservation of particles)
   148→              const particlesPerEdge = 6
   149→              edges.forEach(edge => {
   150→                for (let i = 0; i < particlesPerEdge; i++) {
   151→                  particlePool.push({
   152→                    edge: edge,
   153→                    progress: i / particlesPerEdge, // Evenly distributed
   154→                    active: true // Always active (conserved)
   155→                  })
   156→                }
   157→              })
   158→            }
   159→
   160→            p.frameRate(30)
   161→          }
   162→
   163→          p.draw = () => {
   164→            p.background(250)
   165→
   166→            // Read from refs to avoid re-mounting on state change
   167→            if (simulationErrorRef.current) {
   168→              p.fill(200, 50, 50)
   169→              p.textSize(16)
   170→              p.textAlign(p.CENTER, p.CENTER)
   171→              p.text(simulationErrorRef.current, width / 2, height / 2)
   172→              return
   173→            }
   174→
   175→            if (!simulationRef.current || !data) {
   176→              p.fill(150)
   177→              p.textSize(16)
   178→              p.textAlign(p.CENTER, p.CENTER)
   179→              p.text('No simulation data', width / 2, (height - 100) / 2)
   180→              return
   181→            }
   182→
   183→            // Update node values based on current time (read from ref!)
   184→            updateNodeValues(nodes, simulationRef.current, currentTimeIndexRef.current)
   185→            updateEdgeFlowRates(edges, nodes)
   186→
   187→            // Update particles with variable speed (no spawning - particles are conserved)
   188→            updateParticles(particlePool)
   189→
   190→            // Draw edges
   191→            drawEdges(p, edges)
   192→
   193→            // Draw particles
   194→            drawParticles(p, particlePool)
   195→
   196→            // Draw nodes
   197→            drawNodes(p, nodes)
   198→
   199→            // Draw title
   200→            if (data.title) {
   201→              p.fill(60)
   202→              p.textSize(20)
   203→              p.textAlign(p.CENTER, p.TOP)
   204→              p.text(data.title, width / 2, 10)
   205→            }
   206→
   207→            // Draw time indicator (read from ref!)
   208→            const currentTime = simulationRef.current.t[currentTimeIndexRef.current]
   209→            p.fill(60)
   210→            p.textSize(14)
   211→            p.textAlign(p.RIGHT, p.TOP)
   212→            p.text(`t = ${currentTime.toFixed(2)}s`, width - 20, 10)
   213→          }
   214→
   215→          // Helper functions
   216→          function updateNodeValues(nodes: Node[], sim: SimulationResult, timeIdx: number) {
   217→            nodes.forEach(node => {
   218→              if (node.type === 'input') {
   219→                node.value = sim.u[timeIdx][node.index]
   220→              } else if (node.type === 'state') {
   221→                node.value = sim.x[timeIdx][node.index]
   222→              } else if (node.type === 'output') {
   223→                node.value = sim.y[timeIdx][node.index]
   224→              }
   225→            })
   226→          }
   227→
   228→          function updateEdgeFlowRates(edges: Edge[], nodes: Node[]) {
   229→            edges.forEach(edge => {
   230→              // Flow rate is the weighted contribution from source node
   231→              edge.flowRate = edge.weight * edge.from.value
   232→            })
   233→          }
   234→
   235→          function updateParticles(pool: Particle[]) {
   236→            pool.forEach(particle => {
   237→              const { edge } = particle
   238→
   239→              // Calculate particle speed based on flow rate (variable velocity)
   240→              const baseSpeed = 0.015 // Base speed per frame
   241→              const referenceFlow = 1.0 // Reference flow rate for normalization
   242→
   243→              // Speed proportional to flow magnitude
   244→              const absFlowRate = Math.abs(edge.flowRate)
   245→              const speed = baseSpeed * (absFlowRate / referenceFlow)
   246→
   247→              // Update progress based on flow direction
   248→              if (edge.flowRate >= 0) {
   249→                // Positive flow: move forward
   250→                particle.progress += speed
   251→                if (particle.progress >= 1) {
   252→                  particle.progress -= 1 // Wraparound to start
   253→                }
   254→              } else {
   255→                // Negative flow: move backward
   256→                particle.progress -= speed
   257→                if (particle.progress < 0) {
   258→                  particle.progress += 1 // Wraparound to end
   259→                }
   260→              }
   261→
   262→              // Clamp to [0, 1] just in case
   263→              particle.progress = Math.max(0, Math.min(1, particle.progress))
   264→            })
   265→          }
   266→
   267→          function drawEdges(p: any, edges: Edge[]) {
   268→            edges.forEach(edge => {
   269→              const { from, to, weight, flowRate, bidirectional, parallelOffset } = edge
   270→
   271→              // Arrow color based on current flow direction (not static weight)
   272→              const isPositive = flowRate >= 0
   273→              p.stroke(isPositive ? [50, 150, 50, 50] : [150, 50, 50, 50]) // Red/Green/Blue/Alpha
   274→              p.strokeWeight(PIPE_WIDTH) // Pipe-like width
   275→
   276→              // Draw arrow (parallel pipe if bidirectional, straight otherwise)
   277→              drawArrow(p, from, to, isPositive, bidirectional, parallelOffset)
   278→
   279→              // Calculate label position
   280→              let midX, midY
   281→              if (bidirectional) {
   282→                // For parallel pipes, offset the label position using canonical direction
   283→                const useReverse = from.id > to.id
   284→                const refX1 = useReverse ? to.x : from.x
   285→                const refY1 = useReverse ? to.y : from.y
   286→                const refX2 = useReverse ? from.x : to.x
   287→                const refY2 = useReverse ? from.y : to.y
   288→
   289→                const offset = getParallelOffset(refX1, refY1, refX2, refY2, Math.abs(parallelOffset))
   290→                const sign = parallelOffset > 0 ? 1 : -1
   291→
   292→                midX = (from.x + to.x) / 2 + offset.x * sign
   293→                midY = (from.y + to.y) / 2 + offset.y * sign
   294→              } else {
   295→                midX = (from.x + to.x) / 2
   296→                midY = (from.y + to.y) / 2
   297→              }
   298→
   299→              // Draw +/- sign in the middle
   300→              p.fill(isPositive ? [50, 150, 50] : [150, 50, 50])
   301→              p.noStroke()
   302→              p.textSize(18)
   303→              p.textAlign(p.CENTER, p.CENTER)
   304→              p.text(isPositive ? '+' : '-', midX, midY)
   305→
   306→              // Draw flow rate label
   307→              p.fill(60)
   308→              p.noStroke()
   309→              p.textSize(10)
   310→              p.textAlign(p.CENTER, p.BOTTOM)
   311→              p.text(flowRate.toFixed(2), midX, midY - 15)
   312→
   313→              // Draw weight
   314→              p.textAlign(p.CENTER, p.TOP)
   315→              p.fill(100)
   316→              p.text(`w=${weight.toFixed(2)}`, midX, midY + 15)
   317→            })
   318→          }
   319→
   320→          function drawArrow(p: any, from: Node, to: Node, isPositive: boolean, isBidirectional: boolean, offsetAmount: number) {
   321→            let x1 = from.x
   322→            let y1 = from.y
   323→            let x2 = to.x
   324→            let y2 = to.y
   325→
   326→            // For bidirectional edges, draw parallel pipe offset from center
   327→            if (isBidirectional) {
   328→              // Use a consistent reference direction for perpendicular calculation
   329→              // Always calculate based on the canonical direction (lexicographically smaller ID first)
   330→              const useReverse = from.id > to.id
   331→              const refX1 = useReverse ? x2 : x1
   332→              const refY1 = useReverse ? y2 : y1
   333→              const refX2 = useReverse ? x1 : x2
   334→              const refY2 = useReverse ? y1 : y2
   335→
   336→              // Get perpendicular offset using canonical direction
   337→              const offset = getParallelOffset(refX1, refY1, refX2, refY2, Math.abs(offsetAmount))
   338→
   339→              // Apply offset with correct sign
   340→              const sign = offsetAmount > 0 ? 1 : -1
   341→              x1 += offset.x * sign
   342→              y1 += offset.y * sign
   343→              x2 += offset.x * sign
   344→              y2 += offset.y * sign
   345→            }
   346→
   347→            // Draw pipe (line)
   348→            p.line(x1, y1, x2, y2)
   349→
   350→            // Draw arrowhead proportioned to pipe width
   351→            const angle = p.atan2(y2 - y1, x2 - x1)
   352→            const arrowSize = PIPE_WIDTH * 2.5 // Proportioned to pipe width
   353→
   354→            p.push()
   355→            p.translate(x2, y2)
   356→            p.rotate(angle)
   357→            p.fill(isPositive ? [50, 150, 50] : [150, 50, 50])
   358→            p.noStroke()
   359→            p.triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0)
   360→            p.pop()
   361→          }
   362→
   363→          // Helper: Get parallel offset for bidirectional pipes
   364→          function getParallelOffset(x1: number, y1: number, x2: number, y2: number, offsetAmount: number) {
   365→            // Calculate perpendicular direction
   366→            const dx = x2 - x1
   367→            const dy = y2 - y1
   368→            const len = Math.sqrt(dx * dx + dy * dy)
   369→
   370→            if (len === 0) return { x: 0, y: 0 }
   371→
   372→            // Perpendicular unit vector
   373→            const perpX = -dy / len
   374→            const perpY = dx / len
   375→
   376→            return {
   377→              x: perpX * offsetAmount,
   378→              y: perpY * offsetAmount
   379→            }
   380→          }
   381→
   382→          function drawParticles(p: any, pool: Particle[]) {
   383→            pool.forEach(particle => {
   384→              if (!particle.active) return
   385→
   386→              const { edge, progress } = particle
   387→
   388→              // Calculate base position along the edge
   389→              let x1 = edge.from.x
   390→              let y1 = edge.from.y
   391→              let x2 = edge.to.x
   392→              let y2 = edge.to.y
   393→
   394→              // For bidirectional edges, offset to the parallel pipe using canonical direction
   395→              if (edge.bidirectional) {
   396→                // Use same canonical direction as in drawArrow
   397→                const useReverse = edge.from.id > edge.to.id
   398→                const refX1 = useReverse ? x2 : x1
   399→                const refY1 = useReverse ? y2 : y1
   400→                const refX2 = useReverse ? x1 : x2
   401→                const refY2 = useReverse ? y1 : y2
   402→
   403→                const offset = getParallelOffset(refX1, refY1, refX2, refY2, Math.abs(edge.parallelOffset))
   404→                const sign = edge.parallelOffset > 0 ? 1 : -1
   405→
   406→                x1 += offset.x * sign
   407→                y1 += offset.y * sign
   408→                x2 += offset.x * sign
   409→                y2 += offset.y * sign
   410→              }
   411→
   412→              // Interpolate along the (possibly offset) line
   413→              // Note: direction is already handled in updateParticles (progress increases/decreases)
   414→              const x = p.lerp(x1, x2, progress)
   415→              const y = p.lerp(y1, y2, progress)
   416→
   417→              // Particle color based on current flow direction
   418→              const isPositive = edge.flowRate >= 0
   419→              p.fill(isPositive ? [50, 200, 50, 220] : [200, 50, 50, 220])
   420→              p.noStroke()
   421→              p.circle(x, y, PARTICLE_SIZE)
   422→            })
   423→          }
   424→
   425→          function drawNodes(p: any, nodes: Node[]) {
   426→            nodes.forEach(node => {
   427→              // Node color based on type
   428→              let nodeColor: number[]
   429→              if (node.type === 'input') {
   430→                nodeColor = [100, 150, 255]
   431→              } else if (node.type === 'state') {
   432→                nodeColor = [255, 180, 100]
   433→              } else {
   434→                nodeColor = [150, 100, 255]
   435→              }
   436→
   437→              // Draw circle
   438→              p.fill(nodeColor)
   439→              p.stroke(60)
   440→              p.strokeWeight(2)
   441→              p.circle(node.x, node.y, 60)
   442→
   443→              // Draw label
   444→              p.fill(255)
   445→              p.noStroke()
   446→              p.textSize(12)
   447→              p.textAlign(p.CENTER, p.CENTER)
   448→              p.text(node.label, node.x, node.y)
   449→
   450→              // Draw value below
   451→              p.fill(60)
   452→              p.textSize(11)
   453→              p.textAlign(p.CENTER, p.TOP)
   454→              p.text(node.value.toFixed(3), node.x, node.y + 35)
   455→            })
   456→          }
   457→        }
   458→
   459→        p5 = new P5(sketch)
   460→        setP5Instance(p5)
   461→      }
   462→    }
   463→
   464→    loadP5()
   465→
   466→    return () => {
   467→      isMounted = false
   468→      if (p5) {
   469→        p5.remove()
   470→      }
   471→    }
   472→  }, [data, width, height]) // Don't include refs - they update without re-mounting!
   473→
   474→  // Playback control handlers
   475→  const handlePlayPause = () => {
   476→    if (!simulationRef.current) return
   477→
   478→    if (currentTimeIndex >= simulationRef.current.t.length - 1) {
   479→      // Reset if at end
   480→      setCurrentTimeIndex(0)
   481→      setIsPlaying(true)
   482→    } else {
   483→      setIsPlaying(!isPlaying)
   484→    }
   485→  }
   486→
   487→  const handleStepForward = () => {
   488→    if (!simulationRef.current) return
   489→    setCurrentTimeIndex(Math.min(currentTimeIndex + 1, simulationRef.current.t.length - 1))
   490→  }
   491→
   492→  const handleStepBackward = () => {
   493→    setCurrentTimeIndex(Math.max(currentTimeIndex - 1, 0))
   494→  }
   495→
   496→  const handleReset = () => {
   497→    setCurrentTimeIndex(0)
   498→    setIsPlaying(false)
   499→  }
   500→
   501→  const handleScrub = (e: React.ChangeEvent<HTMLInputElement>) => {
   502→    const value = parseInt(e.target.value)
   503→    setCurrentTimeIndex(value)
   504→  }
   505→
   506→  return (
   507→    <div className="w-full">
   508→      <div ref={canvasRef} />
   509→
   510→      {/* Playback Controls */}
   511→      <div ref={controlsRef} className="mt-4 p-4 bg-gray-100 rounded-lg">
   512→        <div className="flex items-center justify-center gap-4 mb-3">
   513→          <button
   514→            onClick={handleReset}
   515→            className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors"
   516→            disabled={!simulationRef.current}
   517→          >
   518→            Reset
   519→          </button>
   520→
   521→          <button
   522→            onClick={handleStepBackward}
   523→            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
   524→            disabled={!simulationRef.current || currentTimeIndex === 0}
   525→          >
   526→            ← Step
   527→          </button>
   528→
   529→          <button
   530→            onClick={handlePlayPause}
   531→            className="px-6 py-2 bg-green-500 text-white rounded hover:bg-green-600 transition-colors font-semibold"
   532→            disabled={!simulationRef.current}
   533→          >
   534→            {isPlaying ? 'Pause' : 'Play'}
   535→          </button>
   536→
   537→          <button
   538→            onClick={handleStepForward}
   539→            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors"
   540→            disabled={!simulationRef.current || currentTimeIndex >= (simulationRef.current?.t.length ?? 0) - 1}
   541→          >
   542→            Step →
   543→          </button>
   544→        </div>
   545→
   546→        {/* Timeline scrubber */}
   547→        {simulationRef.current && (
   548→          <div className="w-full">
   549→            <input
   550→              type="range"
   551→              min={0}
   552→              max={simulationRef.current.t.length - 1}
   553→              value={currentTimeIndex}
   554→              onChange={handleScrub}
   555→              className="w-full"
   556→            />
   557→            <div className="flex justify-between text-xs text-gray-600 mt-1">
   558→              <span>0s</span>
   559→              <span>{simulationRef.current.t[simulationRef.current.t.length - 1].toFixed(1)}s</span>
   560→            </div>
   561→          </div>
   562→        )}
   563→      </div>
   564→    </div>
   565→  )
   566→}
   567→
   568→// Discrete-time simulation
   569→function runSimulation(data: SystemModelData): SimulationResult {
   570→  const { A, B, C, D, x0, u, dt = 0.1, timeHorizon = 0 } = data
   571→
   572→  // Validate matrices
   573→  const n = A.length // Number of states
   574→  const m = B[0]?.length ?? 0 // Number of inputs
   575→  const p = C.length // Number of outputs
   576→
   577→  if (A.some(row => row.length !== n)) {
   578→    throw new Error('Matrix A must be square (n×n)')
   579→  }
   580→  if (B.length !== n || B.some(row => row.length !== m)) {
   581→    throw new Error('Matrix B must be n×m')
   582→  }
   583→  if (C.some(row => row.length !== n)) {
   584→    throw new Error('Matrix C must be p×n')
   585→  }
   586→  if (D.length !== p || D.some(row => row.length !== m)) {
   587→    throw new Error('Matrix D must be p×m')
   588→  }
   589→  if (x0.length !== n) {
   590→    throw new Error('Initial condition x0 must have length n')
   591→  }
   592→
   593→  // Determine simulation time
   594→  const T = timeHorizon === 0 ? 300 : timeHorizon // 5 minutes default
   595→  const steps = Math.floor(T / dt)
   596→
   597→  // Initialize arrays
   598→  const t: number[] = []
   599→  const x: number[][] = []
   600→  const uArr: number[][] = []
   601→  const y: number[][] = []
   602→
   603→  // Parse input sequence
   604→  let inputSequence: number[][]
   605→  if (Array.isArray(u[0])) {
   606→    // Time-varying input
   607→    inputSequence = u as number[][]
   608→  } else {
   609→    // Constant input - repeat for all time steps
   610→    inputSequence = Array(steps).fill(u as number[])
   611→  }
   612→
   613→  // Initial state
   614→  let xCurrent = [...x0]
   615→
   616→  // Simulate
   617→  for (let k = 0; k < steps; k++) {
   618→    t.push(k * dt)
   619→    x.push([...xCurrent])
   620→
   621→    // Get input at this time step
   622→    const uCurrent = inputSequence[k % inputSequence.length] || Array(m).fill(0)
   623→    uArr.push([...uCurrent])
   624→
   625→    // Compute output: y = Cx + Du
   626→    const yCurrent = matrixVectorMultiply(C, xCurrent).map(
   627→      (val, i) => val + dotProduct(D[i], uCurrent)
   628→    )
   629→    y.push(yCurrent)
   630→
   631→    // Update state: x[k+1] = Ax[k] + Bu[k]
   632→    const Ax = matrixVectorMultiply(A, xCurrent)
   633→    const Bu = matrixVectorMultiply(B, uCurrent)
   634→    xCurrent = Ax.map((val, i) => val + Bu[i])
   635→  }
   636→
   637→  return { t, x, u: uArr, y }
   638→}
   639→
   640→// Matrix-vector multiplication
   641→function matrixVectorMultiply(matrix: number[][], vector: number[]): number[] {
   642→  return matrix.map(row => dotProduct(row, vector))
   643→}
   644→
   645→// Dot product
   646→function dotProduct(a: number[], b: number[]): number {
   647→  return a.reduce((sum, val, i) => sum + val * (b[i] ?? 0), 0)
   648→}
   649→
   650→// Force-directed layout for state nodes based on A matrix structure
   651→function forceDirectedStateLayout(A: number[][], width: number, height: number, margin: number): {x: number, y: number}[] {
   652→  const n = A.length
   653→  if (n === 0) return []
   654→
   655→  // Initialize positions in a circle
   656→  const centerX = width / 2
   657→  const centerY = height / 2
   658→  const radius = Math.min(width - 2 * margin, height - 2 * margin) / 3
   659→
   660→  const positions: {x: number, y: number, vx: number, vy: number}[] = []
   661→  for (let i = 0; i < n; i++) {
   662→    const angle = (i / n) * 2 * Math.PI
   663→    positions.push({
   664→      x: centerX + radius * Math.cos(angle),
   665→      y: centerY + radius * Math.sin(angle),
   666→      vx: 0,
   667→      vy: 0
   668→    })
   669→  }
   670→
   671→  // Force constants
   672→  const k_spring = 0.005  // Spring strength for connected nodes
   673→  const k_repel = 2000    // Repulsion strength
   674→  const k_center = 0.008  // Centering force
   675→  const damping = 0.85    // Velocity damping
   676→  const minDist = 100     // Minimum distance between nodes
   677→
   678→  // Run simulation
   679→  const iterations = 300
   680→  for (let iter = 0; iter < iterations; iter++) {
   681→    const forces: {x: number, y: number}[] = Array(n).fill(null).map(() => ({x: 0, y: 0}))
   682→
   683→    // Attractive forces (springs between connected states)
   684→    for (let i = 0; i < n; i++) {
   685→      for (let j = 0; j < n; j++) {
   686→        if (i === j) continue
   687→        const weight = Math.abs(A[i][j])
   688→        if (weight < 0.001) continue // No connection
   689→
   690→        const dx = positions[j].x - positions[i].x
   691→        const dy = positions[j].y - positions[i].y
   692→        const dist = Math.sqrt(dx * dx + dy * dy)
   693→        if (dist < 0.1) continue
   694→
   695→        // Spring force proportional to connection weight
   696→        const force = k_spring * weight * dist
   697→        forces[i].x += force * dx / dist
   698→        forces[i].y += force * dy / dist
   699→      }
   700→    }
   701→
   702→    // Repulsive forces (prevent overlap)
   703→    for (let i = 0; i < n; i++) {
   704→      for (let j = i + 1; j < n; j++) {
   705→        const dx = positions[j].x - positions[i].x
   706→        const dy = positions[j].y - positions[i].y
   707→        const dist = Math.sqrt(dx * dx + dy * dy)
   708→        if (dist < 0.1) continue
   709→
   710→        const force = k_repel / (dist * dist)
   711→        forces[i].x -= force * dx / dist
   712→        forces[i].y -= force * dy / dist
   713→        forces[j].x += force * dx / dist
   714→        forces[j].y += force * dy / dist
   715→      }
   716→    }
   717→
   718→    // Centering force
   719→    for (let i = 0; i < n; i++) {
   720→      forces[i].x += k_center * (centerX - positions[i].x)
   721→      forces[i].y += k_center * (centerY - positions[i].y)
   722→    }
   723→
   724→    // Update positions
   725→    for (let i = 0; i < n; i++) {
   726→      positions[i].vx = (positions[i].vx + forces[i].x) * damping
   727→      positions[i].vy = (positions[i].vy + forces[i].y) * damping
   728→
   729→      positions[i].x += positions[i].vx
   730→      positions[i].y += positions[i].vy
   731→
   732→      // Keep in bounds
   733→      positions[i].x = Math.max(margin + 60, Math.min(width - margin - 60, positions[i].x))
   734→      positions[i].y = Math.max(margin + 60, Math.min(height - margin - 60, positions[i].y))
   735→    }
   736→  }
   737→
   738→  return positions.map(p => ({x: p.x, y: p.y}))
   739→}
   740→
   741→// Create neural network layout
   742→function createNeuralNetworkLayout(
   743→  data: SystemModelData,
   744→  sim: SimulationResult,
   745→  width: number,
   746→  height: number
   747→): { nodes: Node[], edges: Edge[] } {
   748→  const { A, B, C, labels } = data
   749→
   750→  const n = A.length // States
   751→  const m = B[0]?.length ?? 0 // Inputs
   752→  const p = C.length // Outputs
   753→
   754→  const nodes: Node[] = []
   755→  const margin = 80
   756→  const availableHeight = height - 2 * margin
   757→
   758→  // Input nodes (left column)
   759→  const inputX = margin
   760→  const inputSpacing = m > 1 ? availableHeight / (m + 1) : availableHeight / 2
   761→  for (let i = 0; i < m; i++) {
   762→    nodes.push({
   763→      id: `input_${i}`,
   764→      type: 'input',
   765→      index: i,
   766→      label: labels?.inputs?.[i] || `u${i + 1}`,
   767→      x: inputX,
   768→      y: margin + inputSpacing * (i + 1),
   769→      value: 0
   770→    })
   771→  }
   772→
   773→  // State nodes (force-directed layout based on A matrix)
   774→  const statePositions = forceDirectedStateLayout(A, width, height, margin)
   775→  for (let i = 0; i < n; i++) {
   776→    nodes.push({
   777→      id: `state_${i}`,
   778→      type: 'state',
   779→      index: i,
   780→      label: labels?.states?.[i] || `x${i + 1}`,
   781→      x: statePositions[i].x,
   782→      y: statePositions[i].y,
   783→      value: 0
   784→    })
   785→  }
   786→
   787→  // Output nodes (right column)
   788→  const outputX = width - margin
   789→  const outputSpacing = p > 1 ? availableHeight / (p + 1) : availableHeight / 2
   790→  for (let i = 0; i < p; i++) {
   791→    nodes.push({
   792→      id: `output_${i}`,
   793→      type: 'output',
   794→      index: i,
   795→      label: labels?.outputs?.[i] || `y${i + 1}`,
   796→      x: outputX,
   797→      y: margin + outputSpacing * (i + 1),
   798→      value: 0
   799→    })
   800→  }
   801→
   802→  // Create edges
   803→  const edges: Edge[] = []
   804→
   805→  // Input to state edges (B matrix)
   806→  for (let i = 0; i < n; i++) {
   807→    for (let j = 0; j < m; j++) {
   808→      if (Math.abs(B[i][j]) > 0.001) { // Only show non-zero connections
   809→        const fromNode = nodes.find(n => n.id === `input_${j}`)!
   810→        const toNode = nodes.find(n => n.id === `state_${i}`)!
   811→        edges.push({
   812→          from: fromNode,
   813→          to: toNode,
   814→          weight: B[i][j],
   815→          flowRate: 0,
   816→          bidirectional: false,
   817→          parallelOffset: 0
   818→        })
   819→      }
   820→    }
   821→  }
   822→
   823→  // State to state edges (A matrix)
   824→  for (let i = 0; i < n; i++) {
   825→    for (let j = 0; j < n; j++) {
   826→      if (Math.abs(A[i][j]) > 0.001) {
   827→        const fromNode = nodes.find(n => n.id === `state_${j}`)!
   828→        const toNode = nodes.find(n => n.id === `state_${i}`)!
   829→        edges.push({
   830→          from: fromNode,
   831→          to: toNode,
   832→          weight: A[i][j],
   833→          flowRate: 0,
   834→          bidirectional: false,
   835→          parallelOffset: 0
   836→        })
   837→      }
   838→    }
   839→  }
   840→
   841→  // State to output edges (C matrix)
   842→  for (let i = 0; i < p; i++) {
   843→    for (let j = 0; j < n; j++) {
   844→      if (Math.abs(C[i][j]) > 0.001) {
   845→        const fromNode = nodes.find(n => n.id === `state_${j}`)!
   846→        const toNode = nodes.find(n => n.id === `output_${i}`)!
   847→        edges.push({
   848→          from: fromNode,
   849→          to: toNode,
   850→          weight: C[i][j],
   851→          flowRate: 0,
   852→          bidirectional: false,
   853→          parallelOffset: 0
   854→        })
   855→      }
   856→    }
   857→  }
   858→
   859→  // Detect bidirectional edges using adjacency map approach
   860→  // Build a map: "fromId->toId" => edge
   861→  const edgeMap = new Map<string, Edge>()
   862→  edges.forEach(edge => {
   863→    const key = `${edge.from.id}->${edge.to.id}`
   864→    edgeMap.set(key, edge)
   865→  })
   866→
   867→  // Check for bidirectional pairs and mark them for parallel rendering
   868→  edges.forEach(edge => {
   869→    // Skip self-loops (they can't be bidirectional)
   870→    if (edge.from.id === edge.to.id) return
   871→
   872→    const reverseKey = `${edge.to.id}->${edge.from.id}`
   873→    const reverseEdge = edgeMap.get(reverseKey)
   874→
   875→    if (reverseEdge && !edge.bidirectional) {
   876→      // Found bidirectional pair! Mark both edges
   877→      console.log(`Bidirectional edge detected: ${edge.from.id} ↔ ${edge.to.id}`)
   878→
   879→      edge.bidirectional = true
   880→      edge.parallelOffset = BIDIRECTIONAL_OFFSET
   881→
   882→      reverseEdge.bidirectional = true
   883→      reverseEdge.parallelOffset = -BIDIRECTIONAL_OFFSET
   884→    }
   885→  })
   886→
   887→  const bidirCount = edges.filter(e => e.bidirectional).length
   888→  console.log(`Layout created: ${edges.length} edges, ${bidirCount} bidirectional (${bidirCount/2} pairs)`)
   889→
   890→  return { nodes, edges }
   891→}
   892→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
