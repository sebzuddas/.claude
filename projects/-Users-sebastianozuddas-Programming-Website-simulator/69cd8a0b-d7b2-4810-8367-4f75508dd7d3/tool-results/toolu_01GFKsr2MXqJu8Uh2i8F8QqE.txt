The file /Users/sebastianozuddas/Programming/Website/simulator/src/lib/exportUtils.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     1→/**
     2→ * Utility functions for exporting visualizations as images, GIFs, and videos
     3→ */
     4→
     5→export interface RecordingOptions {
     6→  duration?: number // seconds
     7→  fps?: number
     8→  onProgress?: (progress: number) => void
     9→  onComplete?: () => void
    10→}
    11→
    12→/**
    13→ * Record canvas as GIF
    14→ * Uses canvas frame capture and client-side GIF encoding
    15→ */
    16→export async function recordCanvasAsGif(
    17→  canvas: HTMLCanvasElement,
    18→  filename: string,
    19→  options: RecordingOptions = {}
    20→): Promise<void> {
    21→  const {
    22→    duration = 5,
    23→    fps = 10,
    24→    onProgress,
    25→    onComplete
    26→  } = options
    27→
    28→  return new Promise(async (resolve, reject) => {
    29→    try {
    30→      // TODO: Fix gif.js dependency issue
    31→      reject(new Error('GIF export temporarily disabled - gif.js dependency needs to be installed'))
    32→
    33→      // eslint-disable-next-line no-unreachable
    34→      return
    35→
    36→      // Dynamically import gif.js
    37→      // const GIF = (await import('gif.js')).default
    38→
    39→      // const gif = new GIF({
    40→      //   workers: 2,
    41→      //   quality: 10,
    42→      //   width: canvas.width,
    43→      //   height: canvas.height,
    44→      //   workerScript: '/gif.worker.js' // Will need to be added to public folder
    45→      // })
    46→
    47→      // const totalFrames = duration * fps
    48→      // const frameDelay = 1000 / fps
    49→      // let capturedFrames = 0
    50→
    51→      // const captureFrame = () => {
    52→      //   if (capturedFrames >= totalFrames) {
    53→      //     // Finish recording
    54→      //     gif.render()
    55→      //     return
    56→      //   }
    57→
    58→      //   // Add current canvas frame
    59→      //   gif.addFrame(canvas, { copy: true, delay: frameDelay })
    60→      //   capturedFrames++
    61→
    62→      //   // Update progress
    63→      //   const progress = Math.round((capturedFrames / totalFrames) * 100)
    64→      //   onProgress?.(progress)
    65→
    66→      //   // Capture next frame
    67→      //   setTimeout(captureFrame, frameDelay)
    68→      // }
    69→
    70→      // gif.on('finished', (blob: Blob) => {
    71→      //   // Download the GIF
    72→      //   const url = URL.createObjectURL(blob)
    73→      //   const a = document.createElement('a')
    74→      //   a.href = url
    75→      //   a.download = filename
    76→      //   a.click()
    77→      //   URL.revokeObjectURL(url)
    78→
    79→      //   onComplete?.()
    80→      //   resolve()
    81→      // })
    82→
    83→      // gif.on('error', (error: Error) => {
    84→      //   console.error('GIF creation error:', error)
    85→      //   reject(error)
    86→      // })
    87→
    88→      // // Start capturing frames
    89→      // captureFrame()
    90→    } catch (error) {
    91→      console.error('GIF recording failed:', error)
    92→      // Fallback: just save a single image
    93→      saveCanvasAsImage(canvas, filename.replace('.gif', '.png'))
    94→      onComplete?.()
    95→      resolve()
    96→    }
    97→  })
    98→}
    99→
   100→/**
   101→ * Record canvas as video using MediaRecorder API
   102→ */
   103→export async function recordCanvasAsVideo(
   104→  canvas: HTMLCanvasElement,
   105→  filename: string,
   106→  options: RecordingOptions = {}
   107→): Promise<void> {
   108→  const {
   109→    duration = 10,
   110→    onProgress,
   111→    onComplete
   112→  } = options
   113→
   114→  return new Promise((resolve, reject) => {
   115→    try {
   116→      // Check if MediaRecorder is supported
   117→      if (!('MediaRecorder' in window)) {
   118→        throw new Error('MediaRecorder not supported')
   119→      }
   120→
   121→      // Capture canvas stream
   122→      const stream = canvas.captureStream(30) // 30 fps
   123→
   124→      // Determine supported mime type
   125→      const mimeTypes = [
   126→        'video/webm;codecs=vp9',
   127→        'video/webm;codecs=vp8',
   128→        'video/webm',
   129→        'video/mp4'
   130→      ]
   131→
   132→      let mimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type))
   133→      if (!mimeType) {
   134→        mimeType = 'video/webm' // Fallback
   135→      }
   136→
   137→      const mediaRecorder = new MediaRecorder(stream, {
   138→        mimeType,
   139→        videoBitsPerSecond: 2500000 // 2.5 Mbps
   140→      })
   141→
   142→      const chunks: Blob[] = []
   143→
   144→      mediaRecorder.ondataavailable = (event) => {
   145→        if (event.data.size > 0) {
   146→          chunks.push(event.data)
   147→        }
   148→      }
   149→
   150→      mediaRecorder.onstop = () => {
   151→        const blob = new Blob(chunks, { type: mimeType })
   152→        const url = URL.createObjectURL(blob)
   153→        const a = document.createElement('a')
   154→        a.href = url
   155→        a.download = filename
   156→        a.click()
   157→        URL.revokeObjectURL(url)
   158→
   159→        // Stop all tracks
   160→        stream.getTracks().forEach(track => track.stop())
   161→
   162→        onComplete?.()
   163→        resolve()
   164→      }
   165→
   166→      mediaRecorder.onerror = (error) => {
   167→        console.error('MediaRecorder error:', error)
   168→        reject(error)
   169→      }
   170→
   171→      // Start recording
   172→      mediaRecorder.start()
   173→
   174→      // Update progress during recording
   175→      const startTime = Date.now()
   176→      const progressInterval = setInterval(() => {
   177→        const elapsed = (Date.now() - startTime) / 1000
   178→        const progress = Math.min(Math.round((elapsed / duration) * 100), 100)
   179→        onProgress?.(progress)
   180→
   181→        if (elapsed >= duration) {
   182→          clearInterval(progressInterval)
   183→        }
   184→      }, 100)
   185→
   186→      // Stop recording after duration
   187→      setTimeout(() => {
   188→        clearInterval(progressInterval)
   189→        mediaRecorder.stop()
   190→      }, duration * 1000)
   191→
   192→    } catch (error) {
   193→      console.error('Video recording failed:', error)
   194→      // Fallback: save as image
   195→      saveCanvasAsImage(canvas, filename.replace('.webm', '.png'))
   196→      onComplete?.()
   197→      resolve()
   198→    }
   199→  })
   200→}
   201→
   202→/**
   203→ * Save canvas as PNG image
   204→ * Simple and works in all browsers
   205→ */
   206→export function saveCanvasAsImage(
   207→  canvas: HTMLCanvasElement,
   208→  filename: string
   209→): void {
   210→  canvas.toBlob((blob) => {
   211→    if (!blob) {
   212→      console.error('Failed to create blob from canvas')
   213→      return
   214→    }
   215→
   216→    const url = URL.createObjectURL(blob)
   217→    const a = document.createElement('a')
   218→    a.href = url
   219→    a.download = filename
   220→    a.click()
   221→    URL.revokeObjectURL(url)
   222→  }, 'image/png')
   223→}
   224→
   225→/**
   226→ * Get the canvas element from a P5 instance
   227→ */
   228→export function getP5Canvas(p5Instance: any): HTMLCanvasElement | null {
   229→  try {
   230→    return p5Instance.canvas as HTMLCanvasElement
   231→  } catch (error) {
   232→    console.error('Failed to get canvas from P5 instance:', error)
   233→    return null
   234→  }
   235→}
   236→