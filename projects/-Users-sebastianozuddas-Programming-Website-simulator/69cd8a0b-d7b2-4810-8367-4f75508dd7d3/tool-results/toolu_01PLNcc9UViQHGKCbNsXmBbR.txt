   630→    // This is specialized for Game of Life style simulations
   631→    if (!this.world) return
   632→
   633→    const spatialIndex = this.world.getSpatialIndex()
   634→    if (spatialIndex.type !== 'grid2D') return
   635→
   636→    const gridIndex = spatialIndex as Grid2DSpatialIndex
   637→    const updates: Array<{ entity: EntityClass; nextState: unknown }> = []
   638→
   639→    for (const entity of entities) {
   640→      const entityObj = entity as EntityClass
   641→      const position = entityObj.getComponent<Vector2D>('Position')
   642→      const cellState = entityObj.getComponent<{ alive?: boolean; state?: string }>('CellState')
   643→
   644→      if (position && cellState) {
   645→        const cellX = Math.floor(position.x)
   646→        const cellY = Math.floor(position.y)
   647→        const neighborIds = gridIndex.getNeighbors(cellX, cellY)
   648→        const neighbors = neighborIds.map(id => this.world!.getEntity(id)).filter((e): e is EntityClass => e !== undefined)
   649→
   650→        // Count alive neighbors
   651→        const aliveNeighbors = neighbors.filter(n => {
   652→          const state = n.getComponent<{ alive?: boolean }>('CellState')
   653→          return state?.alive
   654→        }).length
   655→
   656→        // Game of Life rules
   657→        const isAlive = cellState.alive
   658→        let nextAlive = isAlive
   659→
   660→        if (isAlive) {
   661→          // Alive cell: dies if < 2 or > 3 neighbors
   662→          nextAlive = aliveNeighbors === 2 || aliveNeighbors === 3
   663→        } else {
   664→          // Dead cell: becomes alive if exactly 3 neighbors
   665→          nextAlive = aliveNeighbors === 3
   666→        }
   667→
   668→        updates.push({
   669→          entity: entityObj,
   670→          nextState: { alive: nextAlive }
   671→        })
   672→      }
   673→    }
   674→
   675→    // Apply updates (parallel)
   676→    for (const { entity, nextState } of updates) {
   677→      entity.setComponent('CellState', nextState)
   678→    }
   679→  }
   680→
   681→  /**
   682→   * Evaluate a rule for a specific entity
   683→   */
   684→  private evaluateRuleForEntity(rule: RuleDefinition, entity: EntityClass, dt: number, other?: EntityClass): EffectResult | null {
   685→    if (!this.world) return null
   686→
   687→    const ctx: EvaluationContext = {
   688→      world: this.world,
   689→      self: entity,

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
