The file /Users/sebastianozuddas/Programming/Website/simulator/CLAUDE.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   299→  for (let j = i + 1; j < selected.length; j++) {
   300→    drawPhasePlot(stateI, stateJ, ...)
   301→  }
   302→}
   303→```
   304→
   305→#### VectorField Component (`/src/components/visualizations/VectorField.tsx`)
   306→
   307→**Purpose**: Visualizes 2D and 3D vector fields with trajectory integration for linear and nonlinear dynamical systems.
   308→
   309→**Key Features:**
   310→- **2D/3D rendering** - Automatic mode selection based on system dimension
   311→- **Vector field display** - Normalized arrows color-coded by magnitude (blue=low, red=high)
   312→- **Interactive trajectory addition** - Click (2D) or input fields (3D) to add trajectories
   313→- **RK4 integration** - Accurate trajectory computation using 4th-order Runge-Kutta
   314→- **Configurable simulation time** - User-adjustable from 5-60 seconds
   315→- **Playback controls** - Animation with timeline scrubber
   316→- **Color legend** - Visual (2D) or text (3D) explanation of magnitude colors
   317→- **Cross-page navigation** - Integrated with System Simulator and State Space Visualizer
   318→
   319→**Data Format:**
   320→```typescript
   321→interface VectorFieldData {
   322→  // System definition (choose one)
   323→  A?: number[][]                    // Linear: dx/dt = Ax
   324→  f?: (x: number[]) => number[]     // Nonlinear: dx/dt = f(x)
   325→
   326→  // Metadata
   327→  labels?: string[]                 // State labels
   328→  title?: string
   329→
   330→  // Display options
   331→  dimension?: 2 | 3                 // 2D or 3D visualization
   332→  selectedStates?: number[]         // Which states to visualize
   333→
   334→  // Bounds (auto-calculated if not provided)
   335→  bounds?: {
   336→    min: number[]
   337→    max: number[]
   338→  }
   339→}
   340→
   341→interface VectorFieldTrajectory {
   342→  id: string
   343→  x0: number[]                      // Initial condition
   344→  points: number[][]                // Trajectory points [time][state]
   345→  t: number[]                       // Time points
   346→  color: string                     // Display color
   347→}
   348→```
   349→
   350→**Implementation Highlights:**
   351→
   352→1. **2D Click-to-Add Trajectories:**
   353→```typescript
   354→p.mousePressed = () => {
   355→  if (!is3D && p.mouseX > 50 && p.mouseX < width - 50) {
   356→    // Inverse map with Y-axis flip for mathematical convention
   357→    const x = p.map(p.mouseX, 50, width - 50, xMin, xMax)
   358→    const y = p.map(p.mouseY, height - 200, 50, yMin, yMax)  // Note: inverted!
   359→
   360→    integrateTrajectory([x, y])
   361→  }
   362→}
   363→```
   364→
   365→2. **3D Input Fields:**
   366→```typescript
   367→const handleAdd3DTrajectory = () => {
   368→  // Parse and validate input coordinates
   369→  const x = parseFloat(ic3DX)
   370→  const y = parseFloat(ic3DY)
   371→  const z = parseFloat(ic3DZ)
   372→
   373→  // Build full state vector
   374→  const fullState = new Array(n).fill(0)
   375→  fullState[selectedStates[0]] = x
   376→  fullState[selectedStates[1]] = y
   377→  fullState[selectedStates[2]] = z
   378→
   379→  // Integrate using RK4
   380→  integrateTrajectory(fullState)
   381→}
   382→```
   383→
   384→3. **RK4 Integration:**
   385→```typescript
   386→for (let i = 0; i < steps; i++) {
   387→  t.push(i * dt)
   388→  points.push([...state])
   389→
   390→  // 4th-order Runge-Kutta
   391→  const k1 = evaluateSystem(state)
   392→  const k2 = evaluateSystem(state.map((si, j) => si + 0.5 * dt * k1[j]))
   393→  const k3 = evaluateSystem(state.map((si, j) => si + 0.5 * dt * k2[j]))
   394→  const k4 = evaluateSystem(state.map((si, j) => si + dt * k3[j]))
   395→
   396→  state = state.map((si, j) =>
   397→    si + (dt / 6) * (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j])
   398→  )
   399→}
   400→```
   401→
   402→4. **Color Coding by Magnitude:**
   403→```typescript
   404→function magnitudeToColor(mag: number, maxMag: number): [number, number, number] {
   405→  const normalized = Math.min(mag / (maxMag || 1), 1)
   406→  const r = Math.floor(normalized * 255)  // Red for high
   407→  const b = Math.floor((1 - normalized) * 255)  // Blue for low
   408→  return [r, 100, b]
   409→}
   410→```
   411→
   412→5. **Auto-Calculated Bounds:**
   413→```typescript
   414→function calculateBounds(data: VectorFieldData) {
   415→  if (data.A) {
   416→    // For linear systems: estimate from A matrix magnitude
   417→    let maxVal = 0
   418→    for (let i = 0; i < n; i++) {
   419→      for (let j = 0; j < n; j++) {
   420→        maxVal = Math.max(maxVal, Math.abs(data.A[i][j]))
   421→      }
   422→    }
   423→    const bound = Math.max(5, maxVal * 3)
   424→    return {
   425→      min: new Array(n).fill(-bound),
   426→      max: new Array(n).fill(bound)
   427→    }
   428→  }
   429→  // Default for nonlinear systems
   430→  return { min: [-10, -10, -10], max: [10, 10, 10] }
   431→}
   432→```
   433→
   434→**SessionStorage Integration:**
   435→```typescript
   436→// From System Simulator
   437→const openInVectorField = () => {
   438→  const vectorFieldData = {
   439→    A: data.A,
   440→    labels: data.labels?.states,
   441→    title: data.title || 'System Vector Field',
   442→    dimension: data.A.length <= 2 ? 2 : 3
   443→  }
   444→  sessionStorage.setItem('vectorFieldData', JSON.stringify(vectorFieldData))
   445→  router.push('/vectorfield')
   446→}
   447→
   448→// Also stores system matrix when navigating to State Space
   449→sessionStorage.setItem('systemMatrix', JSON.stringify({ A, labels, title }))
   450→```
   451→
   452→**Demo Systems:**
   453→
   454→1. **Mass-Spring-Damper (2D):**
   455→```typescript
   456→const k = 4, m = 1, c = 0.5
   457→const A = [
   458→  [0, 1],
   459→  [-k/m, -c/m]
   460→]
   461→// Shows spiral convergence to equilibrium
   462→```
   463→
   464→2. **Lorenz Attractor (3D):**
   465→```typescript
   466→const sigma = 10, rho = 28, beta = 8/3
   467→const f = (x: number[]) => {
   468→  const [x1, x2, x3] = x
   469→  return [
   470→    sigma * (x2 - x1),
   471→    x1 * (rho - x3) - x2,
   472→    x1 * x2 - beta * x3
   473→  ]
   474→}
   475→// Famous chaotic system with butterfly attractor
   476→```
   477→
   478→**Key Learnings:**
   479→
   480→1. **Y-Axis Inversion Bug** ⚠️
   481→   - P5.js coordinates: y increases downward
   482→   - Math convention: y increases upward
   483→   - **Fix**: Inverse mapping must flip both directions
   484→   ```typescript
   485→   // Forward: state → canvas
   486→   const mapY = (y: number) => p.map(y, yMin, yMax, height-200, 50)
   487→
   488→   // Inverse: canvas → state (MUST match forward flip!)
   489→   const y = p.map(p.mouseY, height-200, 50, yMin, yMax)  // Correct!
   490→   // NOT: p.map(p.mouseY, 50, height-200, yMin, yMax)     // Wrong - reflects on x-axis!
   491→   ```
   492→
   493→2. **WEBGL Limitations** ⚠️
   494→   - `p.hint()` not available in WEBGL mode
   495→   - Can't easily draw 2D overlays on 3D canvas
   496→   - **Solution**: Skip visual legend in 3D, use text description instead
   497→   ```typescript
   498→   // Don't do this in WEBGL:
   499→   p.hint(p.DISABLE_DEPTH_TEST)  // Error: hint is not a function
   500→
   501→   // Instead: conditional rendering
   502→   if (data.dimension === 2) {
   503→     drawColorLegend(p)  // Works fine in 2D mode
   504→   } else {
   505→     // Show text description in UI controls
   506→   }
   507→   ```
   508→
   509→3. **3D Click Input Challenges**
   510→   - Can't reliably map 2D click → 3D position
   511→   - **Solution**: Input fields with bounds validation
   512→   ```typescript
   513→   // Check if coordinates are within bounds
   514→   if (x < xMin || x > xMax || y < yMin || y > yMax || z < zMin || z > zMax) {
   515→     alert(`Coordinates out of bounds! Use:\nx ∈ [${xMin}, ${xMax}]...`)
   516→   }
   517→   ```
   518→
   519→4. **Optional Chaining for Bounds Safety**
   520→   - Bounds may not be loaded when component first renders
   521→   - **Fix**: Use optional chaining and fallbacks
   522→   ```typescript
   523→   {bounds.min[stateIdx]?.toFixed(1) || '?'}  // Safe
   524→   // NOT: bounds.min[stateIdx].toFixed(1)     // Can crash!
   525→   ```
   526→
   527→5. **Simulation Time as User Control**
   528→   - Hardcoded time (20s) not flexible for all systems
   529→   - **Solution**: Slider with sensible limits (5-60s)
   530→   - Chaotic systems need longer time to show full dynamics
   531→   - Damped systems converge quickly, shorter time sufficient
   532→
   533→**Navigation Flow:**
   534→```
   535→System Simulator → [View Vector Field] → Vector Field (with A matrix)
   536→                → [View Phase Portrait] → State Space (with trajectories)
   537→                                        → [View Vector Field] → Vector Field (if system matrix available)
   538→
   539→Vector Field → [System Simulator] → System Model page
   540→            → [Phase Portrait] → State Space page
   541→```
   542→
   543→### Utility Classes (`/src/lib/utils.ts`)
   544→
   545→#### ColorUtils
   546→- **Static color palette generation** - Viridis, Plasma, Inferno, Magma, etc.
   547→- **Theme configuration loading** - Loads from `/data/color-palettes.json`