   225→
   226→          function updateEdgeFlowRates(edges: Edge[], nodes: Node[]) {
   227→            edges.forEach(edge => {
   228→              // Flow rate is the weighted contribution from source node
   229→              edge.flowRate = edge.weight * edge.from.value
   230→            })
   231→          }
   232→
   233→          function spawnParticles(edges: Edge[], pool: Particle[]) {
   234→            edges.forEach(edge => {
   235→              // Spawn particles based on flow magnitude (1-5 particles)
   236→              const absFlow = Math.abs(edge.flowRate)
   237→              const particleCount = Math.min(5, Math.max(1, Math.floor(absFlow * 3)))
   238→
   239→              for (let i = 0; i < particleCount; i++) {
   240→                const available = pool.find(p => !p.active)
   241→                if (available) {
   242→                  available.edge = edge
   243→                  available.progress = Math.random() * 0.2 // Stagger spawn
   244→                  available.active = true
   245→                }
   246→              }
   247→            })
   248→          }
   249→
   250→          function updateParticles(pool: Particle[]) {
   251→            pool.forEach(particle => {
   252→              if (!particle.active) return
   253→
   254→              particle.progress += 0.02 // Speed of particle movement
   255→
   256→              if (particle.progress >= 1) {
   257→                particle.active = false
   258→                particle.progress = 0
   259→              }
   260→            })
   261→          }
   262→
   263→          function drawEdges(p: any, edges: Edge[]) {
   264→            edges.forEach(edge => {
   265→              const { from, to, weight, flowRate } = edge
   266→
   267→              // Arrow color based on positive/negative
   268→              const isPositive = weight >= 0
   269→              p.stroke(isPositive ? [50, 150, 50] : [150, 50, 50])
   270→              p.strokeWeight(2)
   271→
   272→              // Draw arrow
   273→              drawArrow(p, from.x, from.y, to.x, to.y, isPositive)
   274→
   275→              // Draw flow rate label
   276→              const midX = (from.x + to.x) / 2
   277→              const midY = (from.y + to.y) / 2
   278→              p.fill(60)
   279→              p.noStroke()
   280→              p.textSize(10)
   281→              p.textAlign(p.CENTER, p.BOTTOM)
   282→              p.text(flowRate.toFixed(2), midX, midY - 5)
   283→
   284→              // Draw weight
   285→              p.textAlign(p.CENTER, p.TOP)
   286→              p.fill(100)
   287→              p.text(`w=${weight.toFixed(2)}`, midX, midY + 5)
   288→            })
   289→          }
   290→
   291→          function drawArrow(p: any, x1: number, y1: number, x2: number, y2: number, isPositive: boolean) {
   292→            // Draw line
   293→            p.line(x1, y1, x2, y2)
   294→
   295→            // Draw arrowhead
   296→            const angle = p.atan2(y2 - y1, x2 - x1)
   297→            const arrowSize = 10
   298→
   299→            p.push()
   300→            p.translate(x2, y2)
   301→            p.rotate(angle)
   302→            p.fill(isPositive ? [50, 150, 50] : [150, 50, 50])
   303→            p.noStroke()
   304→            p.triangle(-arrowSize, -arrowSize/2, -arrowSize, arrowSize/2, 0, 0)

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
