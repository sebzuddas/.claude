The file /Users/sebastianozuddas/Programming/Website/simulator/src/components/visualizations/SystemModel.tsx has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   261→              }
   262→            })
   263→          }
   264→
   265→          function drawEdges(p: any, edges: Edge[]) {
   266→            edges.forEach(edge => {
   267→              const { from, to, weight, flowRate, curved, curveOffset } = edge
   268→
   269→              // Arrow color based on positive/negative
   270→              const isPositive = weight >= 0
   271→              p.stroke(isPositive ? [50, 150, 50] : [150, 50, 50])
   272→              p.strokeWeight(3) // Thicker line for better visibility
   273→
   274→              // Draw arrow (curved or straight)
   275→              drawArrow(p, from, to, isPositive, curved, curveOffset)
   276→
   277→              // Calculate label position (on the curve if curved)
   278→              let midX, midY
   279→              if (curved) {
   280→                // Get point at t=0.5 on the curve
   281→                const midPoint = getPointOnCurve(from.x, from.y, to.x, to.y, curveOffset, 0.5)
   282→                midX = midPoint.x
   283→                midY = midPoint.y
   284→              } else {
   285→                midX = (from.x + to.x) / 2
   286→                midY = (from.y + to.y) / 2
   287→              }
   288→
   289→              // Draw flow rate label
   290→              p.fill(60)
   291→              p.noStroke()
   292→              p.textSize(10)
   293→              p.textAlign(p.CENTER, p.BOTTOM)
   294→              p.text(flowRate.toFixed(2), midX, midY - 8)
   295→
   296→              // Draw weight
   297→              p.textAlign(p.CENTER, p.TOP)
   298→              p.fill(100)
   299→              p.text(`w=${weight.toFixed(2)}`, midX, midY + 8)
   300→            })
   301→          }
   302→
   303→          function drawArrow(p: any, from: Node, to: Node, isPositive: boolean, curved: boolean, curveOffset: number) {
   304→            const x1 = from.x
   305→            const y1 = from.y
   306→            const x2 = to.x
   307→            const y2 = to.y
   308→
   309→            if (curved) {
   310→              // Draw curved arrow using quadratic bezier
   311→              const controlPoint = getCurveControlPoint(x1, y1, x2, y2, curveOffset)
   312→
   313→              p.noFill()
   314→              p.beginShape()
   315→              p.vertex(x1, y1)
   316→              p.quadraticVertex(controlPoint.x, controlPoint.y, x2, y2)
   317→              p.endShape()
   318→
   319→              // Draw arrowhead at the end (pointing along curve)
   320→              const t = 0.95 // Position just before endpoint
   321→              const endPoint = getPointOnCurve(x1, y1, x2, y2, curveOffset, t)
   322→              const angle = Math.atan2(y2 - endPoint.y, x2 - endPoint.x)
   323→
   324→              const arrowSize = 15 // Larger arrow
   325→              p.push()
   326→              p.translate(x2, y2)
   327→              p.rotate(angle)
   328→              p.fill(isPositive ? [50, 150, 50] : [150, 50, 50])
   329→              p.noStroke()
   330→              p.triangle(-arrowSize, -arrowSize/2, -arrowSize, arrowSize/2, 0, 0)
   331→              p.pop()
   332→
   333→            } else {
   334→              // Straight arrow
   335→              p.line(x1, y1, x2, y2)
   336→
   337→              // Draw arrowhead
   338→              const angle = p.atan2(y2 - y1, x2 - x1)
   339→              const arrowSize = 15 // Larger arrow
   340→
   341→              p.push()
   342→              p.translate(x2, y2)
   343→              p.rotate(angle)
   344→              p.fill(isPositive ? [50, 150, 50] : [150, 50, 50])
   345→              p.noStroke()
   346→              p.triangle(-arrowSize, -arrowSize/2, -arrowSize, arrowSize/2, 0, 0)
   347→              p.pop()
   348→            }
   349→
   350→            // Draw +/- sign near the endpoint
   351→            const offset = curved ? 25 : 20
   352→            const signAngle = curved
   353→              ? Math.atan2(y2 - getPointOnCurve(x1, y1, x2, y2, curveOffset, 0.95).y,
   354→                          x2 - getPointOnCurve(x1, y1, x2, y2, curveOffset, 0.95).x)
   355→              : Math.atan2(y2 - y1, x2 - x1)
   356→            const signX = x2 + offset * Math.cos(signAngle + Math.PI/2)
   357→            const signY = y2 + offset * Math.sin(signAngle + Math.PI/2)
   358→
   359→            p.fill(isPositive ? [50, 150, 50] : [150, 50, 50])
   360→            p.textSize(16)
   361→            p.textAlign(p.CENTER, p.CENTER)
   362→            p.text(isPositive ? '+' : '-', signX, signY)
   363→          }
   364→
   365→          // Helper: Get control point for quadratic bezier curve
   366→          function getCurveControlPoint(x1: number, y1: number, x2: number, y2: number, offset: number) {
   367→            const midX = (x1 + x2) / 2
   368→            const midY = (y1 + y2) / 2
   369→
   370→            // Perpendicular vector
   371→            const dx = x2 - x1
   372→            const dy = y2 - y1
   373→            const len = Math.sqrt(dx * dx + dy * dy)
   374→            const perpX = -dy / len
   375→            const perpY = dx / len
   376→
   377→            return {
   378→              x: midX + perpX * offset,
   379→              y: midY + perpY * offset
   380→            }
   381→          }
   382→
   383→          // Helper: Get point on quadratic bezier curve at parameter t (0 to 1)
   384→          function getPointOnCurve(x1: number, y1: number, x2: number, y2: number, offset: number, t: number) {
   385→            const control = getCurveControlPoint(x1, y1, x2, y2, offset)
   386→            const oneMinusT = 1 - t
   387→
   388→            return {
   389→              x: oneMinusT * oneMinusT * x1 + 2 * oneMinusT * t * control.x + t * t * x2,
   390→              y: oneMinusT * oneMinusT * y1 + 2 * oneMinusT * t * control.y + t * t * y2
   391→            }
   392→          }
   393→
   394→          function drawParticles(p: any, pool: Particle[]) {
   395→            pool.forEach(particle => {
   396→              if (!particle.active) return