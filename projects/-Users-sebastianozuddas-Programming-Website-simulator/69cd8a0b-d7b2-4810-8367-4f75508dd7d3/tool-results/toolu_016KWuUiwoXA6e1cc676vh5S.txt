   115→          function draw2D(p: any) {
   116→            const selectedStates = data.selectedStates || [0, 1]
   117→            const stateX = selectedStates[0]
   118→            const stateY = selectedStates[1]
   119→
   120→            const xMin = bounds!.min[stateX]
   121→            const xMax = bounds!.max[stateX]
   122→            const yMin = bounds!.min[stateY]
   123→            const yMax = bounds!.max[stateY]
   124→
   125→            // Map function from state space to canvas
   126→            const mapX = (x: number) => p.map(x, xMin, xMax, 50, width - 50)
   127→            const mapY = (y: number) => p.map(y, yMin, yMax, height - 200, 50)
   128→
   129→            // Draw axes
   130→            p.stroke(200)
   131→            p.strokeWeight(1)
   132→            p.line(50, mapY(0), width - 50, mapY(0)) // X-axis
   133→            p.line(mapX(0), 50, mapX(0), height - 200) // Y-axis
   134→
   135→            // Draw border
   136→            p.stroke(100)
   137→            p.noFill()
   138→            p.rect(50, 50, width - 100, height - 250)
   139→
   140→            // Draw vector field
   141→            if (showArrows) {
   142→              drawVectorField2D(p, mapX, mapY, stateX, stateY, xMin, xMax, yMin, yMax)
   143→            }
   144→
   145→            // Draw trajectories
   146→            trajectories.forEach((traj, idx) => {
   147→              drawTrajectory2D(p, traj, mapX, mapY, stateX, stateY, idx)
   148→            })
   149→
   150→            // Draw labels
   151→            const labelX = data.labels?.[stateX] || `x${stateX + 1}`
   152→            const labelY = data.labels?.[stateY] || `x${stateY + 1}`
   153→
   154→            p.fill(60)
   155→            p.noStroke()
   156→            p.textSize(14)
   157→            p.textAlign(p.CENTER, p.TOP)
   158→            p.text(labelX, width / 2, height - 180)
   159→
   160→            p.push()
   161→            p.translate(20, height / 2 - 100)
   162→            p.rotate(-p.HALF_PI)
   163→            p.textAlign(p.CENTER, p.TOP)
   164→            p.text(labelY, 0, 0)
   165→            p.pop()
   166→
   167→            // Title
   168→            if (data.title) {
   169→              p.fill(60)
   170→              p.textSize(18)
   171→              p.textAlign(p.CENTER, p.TOP)
   172→              p.text(data.title, width / 2, 10)
   173→            }
   174→          }
   175→
   176→          function draw3D(p: any) {
   177→            // 3D rendering
   178→            p.orbitControl()
   179→
   180→            const selectedStates = data.selectedStates || [0, 1, 2]
   181→            const stateX = selectedStates[0]
   182→            const stateY = selectedStates[1]
   183→            const stateZ = selectedStates[2]
   184→
   185→            const xMin = bounds!.min[stateX]
   186→            const xMax = bounds!.max[stateX]
   187→            const yMin = bounds!.min[stateY]
   188→            const yMax = bounds!.max[stateY]
   189→            const zMin = bounds!.min[stateZ]
   190→            const zMax = bounds!.max[stateZ]
   191→
   192→            const scale = 100
   193→
   194→            // Map function
   195→            const mapVal = (val: number, min: number, max: number) =>
   196→              p.map(val, min, max, -scale, scale)
   197→
   198→            // Draw axes
   199→            p.stroke(200, 0, 0)
   200→            p.strokeWeight(2)
   201→            p.line(-scale, 0, 0, scale, 0, 0) // X-axis
   202→
   203→            p.stroke(0, 200, 0)
   204→            p.line(0, -scale, 0, 0, scale, 0) // Y-axis
   205→
   206→            p.stroke(0, 0, 200)
   207→            p.line(0, 0, -scale, 0, 0, scale) // Z-axis
   208→
   209→            // Draw vector field
   210→            if (showArrows) {
   211→              drawVectorField3D(p, mapVal, stateX, stateY, stateZ, xMin, xMax, yMin, yMax, zMin, zMax, scale)
   212→            }
   213→
   214→            // Draw trajectories

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
