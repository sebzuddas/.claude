     1→/**
     2→ * Utility functions for exporting visualizations as images, GIFs, and videos
     3→ */
     4→
     5→export interface RecordingOptions {
     6→  duration?: number // seconds
     7→  fps?: number
     8→  onProgress?: (progress: number) => void
     9→  onComplete?: () => void
    10→}
    11→
    12→/**
    13→ * Record canvas as GIF
    14→ * Uses canvas frame capture and client-side GIF encoding
    15→ */
    16→export async function recordCanvasAsGif(
    17→  canvas: HTMLCanvasElement,
    18→  filename: string,
    19→  options: RecordingOptions = {}
    20→): Promise<void> {
    21→  const {
    22→    duration = 5,
    23→    fps = 10,
    24→    onProgress,
    25→    onComplete
    26→  } = options
    27→
    28→  return new Promise(async (resolve, reject) => {
    29→    try {
    30→      // TODO: Fix gif.js dependency issue
    31→      reject(new Error('GIF export temporarily disabled - gif.js dependency needs to be installed'))
    32→      return
    33→
    34→      // Dynamically import gif.js
    35→      // const GIF = (await import('gif.js')).default
    36→
    37→      // const gif = new GIF({
    38→      //   workers: 2,
    39→      //   quality: 10,
    40→      //   width: canvas.width,
    41→      //   height: canvas.height,
    42→      //   workerScript: '/gif.worker.js' // Will need to be added to public folder
    43→      // })
    44→
    45→      const totalFrames = duration * fps
    46→      const frameDelay = 1000 / fps
    47→      let capturedFrames = 0
    48→
    49→      const captureFrame = () => {
    50→        if (capturedFrames >= totalFrames) {
    51→          // Finish recording
    52→          gif.render()
    53→          return
    54→        }
    55→
    56→        // Add current canvas frame
    57→        gif.addFrame(canvas, { copy: true, delay: frameDelay })
    58→        capturedFrames++
    59→
    60→        // Update progress
    61→        const progress = Math.round((capturedFrames / totalFrames) * 100)
    62→        onProgress?.(progress)
    63→
    64→        // Capture next frame
    65→        setTimeout(captureFrame, frameDelay)
    66→      }
    67→
    68→      gif.on('finished', (blob: Blob) => {
    69→        // Download the GIF
    70→        const url = URL.createObjectURL(blob)
    71→        const a = document.createElement('a')
    72→        a.href = url
    73→        a.download = filename
    74→        a.click()
    75→        URL.revokeObjectURL(url)
    76→
    77→        onComplete?.()
    78→        resolve()
    79→      })
    80→
    81→      gif.on('error', (error: Error) => {
    82→        console.error('GIF creation error:', error)
    83→        reject(error)
    84→      })
    85→
    86→      // Start capturing frames
    87→      captureFrame()
    88→    } catch (error) {
    89→      console.error('GIF recording failed:', error)
    90→      // Fallback: just save a single image
    91→      saveCanvasAsImage(canvas, filename.replace('.gif', '.png'))
    92→      onComplete?.()
    93→      resolve()
    94→    }
    95→  })
    96→}
    97→
    98→/**
    99→ * Record canvas as video using MediaRecorder API
   100→ */
   101→export async function recordCanvasAsVideo(
   102→  canvas: HTMLCanvasElement,
   103→  filename: string,
   104→  options: RecordingOptions = {}
   105→): Promise<void> {
   106→  const {
   107→    duration = 10,
   108→    onProgress,
   109→    onComplete
   110→  } = options
   111→
   112→  return new Promise((resolve, reject) => {
   113→    try {
   114→      // Check if MediaRecorder is supported
   115→      if (!('MediaRecorder' in window)) {
   116→        throw new Error('MediaRecorder not supported')
   117→      }
   118→
   119→      // Capture canvas stream
   120→      const stream = canvas.captureStream(30) // 30 fps
   121→
   122→      // Determine supported mime type
   123→      const mimeTypes = [
   124→        'video/webm;codecs=vp9',
   125→        'video/webm;codecs=vp8',
   126→        'video/webm',
   127→        'video/mp4'
   128→      ]
   129→
   130→      let mimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type))
   131→      if (!mimeType) {
   132→        mimeType = 'video/webm' // Fallback
   133→      }
   134→
   135→      const mediaRecorder = new MediaRecorder(stream, {
   136→        mimeType,
   137→        videoBitsPerSecond: 2500000 // 2.5 Mbps
   138→      })
   139→
   140→      const chunks: Blob[] = []
   141→
   142→      mediaRecorder.ondataavailable = (event) => {
   143→        if (event.data.size > 0) {
   144→          chunks.push(event.data)
   145→        }
   146→      }
   147→
   148→      mediaRecorder.onstop = () => {
   149→        const blob = new Blob(chunks, { type: mimeType })
   150→        const url = URL.createObjectURL(blob)
   151→        const a = document.createElement('a')
   152→        a.href = url
   153→        a.download = filename
   154→        a.click()
   155→        URL.revokeObjectURL(url)
   156→
   157→        // Stop all tracks
   158→        stream.getTracks().forEach(track => track.stop())
   159→
   160→        onComplete?.()
   161→        resolve()
   162→      }
   163→
   164→      mediaRecorder.onerror = (error) => {
   165→        console.error('MediaRecorder error:', error)
   166→        reject(error)
   167→      }
   168→
   169→      // Start recording
   170→      mediaRecorder.start()
   171→
   172→      // Update progress during recording
   173→      const startTime = Date.now()
   174→      const progressInterval = setInterval(() => {
   175→        const elapsed = (Date.now() - startTime) / 1000
   176→        const progress = Math.min(Math.round((elapsed / duration) * 100), 100)
   177→        onProgress?.(progress)
   178→
   179→        if (elapsed >= duration) {
   180→          clearInterval(progressInterval)
   181→        }
   182→      }, 100)
   183→
   184→      // Stop recording after duration
   185→      setTimeout(() => {
   186→        clearInterval(progressInterval)
   187→        mediaRecorder.stop()
   188→      }, duration * 1000)
   189→
   190→    } catch (error) {
   191→      console.error('Video recording failed:', error)
   192→      // Fallback: save as image
   193→      saveCanvasAsImage(canvas, filename.replace('.webm', '.png'))
   194→      onComplete?.()
   195→      resolve()
   196→    }
   197→  })
   198→}
   199→
   200→/**
   201→ * Save canvas as PNG image
   202→ * Simple and works in all browsers
   203→ */
   204→export function saveCanvasAsImage(
   205→  canvas: HTMLCanvasElement,
   206→  filename: string
   207→): void {
   208→  canvas.toBlob((blob) => {
   209→    if (!blob) {
   210→      console.error('Failed to create blob from canvas')
   211→      return
   212→    }
   213→
   214→    const url = URL.createObjectURL(blob)
   215→    const a = document.createElement('a')
   216→    a.href = url
   217→    a.download = filename
   218→    a.click()
   219→    URL.revokeObjectURL(url)
   220→  }, 'image/png')
   221→}
   222→
   223→/**
   224→ * Get the canvas element from a P5 instance
   225→ */
   226→export function getP5Canvas(p5Instance: any): HTMLCanvasElement | null {
   227→  try {
   228→    return p5Instance.canvas as HTMLCanvasElement
   229→  } catch (error) {
   230→    console.error('Failed to get canvas from P5 instance:', error)
   231→    return null
   232→  }
   233→}
   234→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
