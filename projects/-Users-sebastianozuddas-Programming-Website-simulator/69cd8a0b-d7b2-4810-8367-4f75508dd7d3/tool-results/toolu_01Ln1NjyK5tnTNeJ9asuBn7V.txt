The file /Users/sebastianozuddas/Programming/Website/simulator/src/app/abm/page.tsx has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   595→    </VisualizationLayout>
   596→  )
   597→}
   598→
   599→// =============================================================================
   600→// TIMESERIES PLOT COMPONENT
   601→// =============================================================================
   602→
   603→interface TimeseriesPlotProps {
   604→  data: Map<string, TimeseriesData>
   605→  type: 'aggregate' | 'individual'
   606→}
   607→
   608→function TimeseriesPlot({ data, type }: TimeseriesPlotProps) {
   609→  const canvasRef = useRef<HTMLCanvasElement>(null)
   610→
   611→  useEffect(() => {
   612→    const canvas = canvasRef.current
   613→    if (!canvas) return
   614→
   615→    const ctx = canvas.getContext('2d')
   616→    if (!ctx) return
   617→
   618→    const rect = canvas.getBoundingClientRect()
   619→    canvas.width = rect.width * window.devicePixelRatio
   620→    canvas.height = rect.height * window.devicePixelRatio
   621→    ctx.scale(window.devicePixelRatio, window.devicePixelRatio)
   622→
   623→    const width = rect.width
   624→    const height = rect.height
   625→    const padding = 40
   626→
   627→    // Clear
   628→    ctx.fillStyle = '#f9fafb'
   629→    ctx.fillRect(0, 0, width, height)
   630→
   631→    // Filter data based on type
   632→    // Aggregate: population counts, totals (names containing 'count', 'total', 'population')
   633→    // Individual: averages, per-agent metrics (names containing 'avg', 'mean', 'individual')
   634→    const filteredData = new Map<string, TimeseriesData>()
   635→    const aggregateKeywords = ['count', 'total', 'population', 'susceptible', 'infected', 'recovered', 'prey', 'predator', 'boid']
   636→    const individualKeywords = ['avg', 'mean', 'average', 'speed', 'energy', 'distance']
   637→
   638→    data.forEach((ts, name) => {
   639→      const nameLower = name.toLowerCase()
   640→      if (type === 'aggregate') {
   641→        // Include if matches aggregate keywords OR doesn't match individual keywords
   642→        const isAggregate = aggregateKeywords.some(kw => nameLower.includes(kw))
   643→        const isIndividual = individualKeywords.some(kw => nameLower.includes(kw))
   644→        if (isAggregate || !isIndividual) {
   645→          filteredData.set(name, ts)
   646→        }
   647→      } else {
   648→        // Individual: include if matches individual keywords
   649→        const isIndividual = individualKeywords.some(kw => nameLower.includes(kw))
   650→        if (isIndividual) {
   651→          filteredData.set(name, ts)
   652→        }
   653→      }
   654→    })
   655→
   656→    // If no filtered data for individual, show all data but labeled differently
   657→    const displayData = filteredData.size > 0 ? filteredData : (type === 'aggregate' ? data : new Map())
   658→
   659→    if (displayData.size === 0) {
   660→      ctx.fillStyle = '#9ca3af'
   661→      ctx.font = '14px sans-serif'
   662→      ctx.textAlign = 'center'
   663→      ctx.fillText(
   664→        type === 'individual' ? 'No individual-level metrics defined' : 'No data available',
   665→        width / 2,
   666→        height / 2
   667→      )
   668→      return
   669→    }
   670→
   671→    // Find data range
   672→    let minVal = Infinity
   673→    let maxVal = -Infinity
   674→    let maxTick = 0
   675→
   676→    displayData.forEach(ts => {
   677→      for (const v of ts.values) {
   678→        minVal = Math.min(minVal, v)
   679→        maxVal = Math.max(maxVal, v)
   680→      }
   681→      maxTick = Math.max(maxTick, ts.ticks.length > 0 ? ts.ticks[ts.ticks.length - 1] : 0)
   682→    })
   683→
   684→    if (minVal === Infinity) return
   685→
   686→    // Add padding to range
   687→    const range = maxVal - minVal || 1
   688→    minVal -= range * 0.1
   689→    maxVal += range * 0.1
   690→
   691→    // Draw axes
   692→    ctx.strokeStyle = '#ccc'
   693→    ctx.lineWidth = 1
   694→    ctx.beginPath()
   695→    ctx.moveTo(padding, padding)
   696→    ctx.lineTo(padding, height - padding)
   697→    ctx.lineTo(width - padding, height - padding)
   698→    ctx.stroke()
   699→
   700→    // Draw axis labels
   701→    ctx.fillStyle = '#666'
   702→    ctx.font = '10px sans-serif'
   703→    ctx.textAlign = 'center'
   704→    ctx.fillText('Time (ticks)', width / 2, height - 5)
   705→    ctx.save()
   706→    ctx.translate(12, height / 2)
   707→    ctx.rotate(-Math.PI / 2)
   708→    ctx.fillText(type === 'aggregate' ? 'Count' : 'Value', 0, 0)
   709→    ctx.restore()
   710→
   711→    // Colors for each series
   712→    const colors = type === 'aggregate'
   713→      ? ['#4285f4', '#ea4335', '#fbbc04', '#34a853', '#ff6d01', '#9b59b6']
   714→      : ['#8e44ad', '#16a085', '#e67e22', '#2980b9', '#c0392b']
   715→    let colorIndex = 0
   716→
   717→    // Draw data
   718→    displayData.forEach((ts, name) => {
   719→      if (ts.values.length < 2) return
   720→
   721→      ctx.strokeStyle = colors[colorIndex % colors.length]
   722→      ctx.lineWidth = 2
   723→      ctx.beginPath()
   724→
   725→      for (let i = 0; i < ts.values.length; i++) {
   726→        const x = padding + (ts.ticks[i] / maxTick) * (width - 2 * padding)
   727→        const y = height - padding - ((ts.values[i] - minVal) / (maxVal - minVal)) * (height - 2 * padding)
   728→
   729→        if (i === 0) {
   730→          ctx.moveTo(x, y)
   731→        } else {
   732→          ctx.lineTo(x, y)
   733→        }
   734→      }
   735→
   736→      ctx.stroke()
   737→      colorIndex++
   738→    })
   739→
   740→    // Draw legend
   741→    colorIndex = 0
   742→    let legendY = 10
   743→    const legendX = width - 120
   744→    displayData.forEach((ts, name) => {
   745→      ctx.fillStyle = colors[colorIndex % colors.length]
   746→      ctx.fillRect(legendX, legendY, 12, 12)
   747→      ctx.fillStyle = '#333'
   748→      ctx.font = '11px sans-serif'
   749→      ctx.textAlign = 'left'
   750→      // Truncate long names
   751→      const displayName = name.length > 12 ? name.slice(0, 10) + '...' : name
   752→      ctx.fillText(displayName, legendX + 16, legendY + 10)
   753→      legendY += 16
   754→      colorIndex++
   755→    })
   756→
   757→  }, [data, type])
   758→
   759→  return (
   760→    <canvas
   761→      ref={canvasRef}
   762→      className="w-full h-full"
   763→    />
   764→  )
   765→}
   766→